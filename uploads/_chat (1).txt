[06/09/22, 11:45:28] Equipo Tarea 2 IS: â€Los mensajes y las llamadas estÃ¡n cifrados de extremo a extremo. Nadie fuera de este chat, ni siquiera WhatsApp, puede leerlos ni escucharlos.
[06/09/22, 11:45:28] â€Raul Moreno creÃ³ este grupo.
[06/09/22, 11:49:23] â€Raul Moreno te aÃ±adiÃ³.
[06/09/22, 11:49:34] â€Ahora eres admin. del grupo
[06/09/22, 11:49:44] â€+52 444 380 2885 aÃ±adiÃ³ a Kevin MÃ¡rquez
[06/09/22, 11:50:34] â€â€ª+52Â 444Â 374Â 1420â€¬ se uniÃ³ usando el enlace de invitaciÃ³n de este grupo
[06/09/22, 11:52:53] Mikel Barajas: Hola equipo
[06/09/22, 11:52:05] â€â€ª+52Â 444Â 136Â 6505â€¬ se uniÃ³ usando el enlace de invitaciÃ³n de este grupo
[06/09/22, 11:53:59] â€â€ª+52Â 444Â 718Â 5474â€¬ se uniÃ³ usando el enlace de invitaciÃ³n de este grupo
[06/09/22, 11:54:19] â€ª+52Â 444Â 718Â 5474â€¬: QuiÃ©n estÃ¡ a cargo?
[06/09/22, 11:54:29] Mikel Barajas: PodrÃ­a ser yo
[06/09/22, 11:54:35] Mikel Barajas: Si estÃ¡n de acuerdo los demÃ¡s?
[06/09/22, 11:54:42] Raul Moreno: Yo si
[06/09/22, 11:54:53] â€ª+52Â 444Â 718Â 5474â€¬: Yo no
[06/09/22, 11:54:54] Mikel Barajas: Sin el signo de interrogaciÃ³n *
[06/09/22, 11:55:11] â€ª+52Â 444Â 718Â 5474â€¬: Avdd
[06/09/22, 11:55:20] â€ª+52Â 444Â 718Â 5474â€¬: Xd
[06/09/22, 11:55:35] â€ª+52Â 444Â 718Â 5474â€¬: Pues como vean ustedes
[06/09/22, 11:57:57] â€ª+52Â 444Â 380Â 2885â€¬: Por mi estÃ¡ bien
[06/09/22, 12:07:59] â€ª+52Â 444Â 285Â 9212â€¬: Hola
[06/09/22, 12:08:01] â€ª+52Â 444Â 285Â 9212â€¬: Si
[06/09/22, 12:13:37] Montserrat Gallegos: Ei
â€[06/09/22, 12:13:53] Montserrat Gallegos: â€sticker omitido
â€[07/09/22, 15:29:45] Raul Moreno: Tarea-2-REQUERIMIENTOS Y TRABAJO EN EQUIPO 2022-otonÌƒo.pdf â€¢ â€2 pÃ¡ginas â€documento omitido
[07/09/22, 15:30:18] Raul Moreno: El profesor ya subiÃ³ los requerimientos de la tarea, se los pasÃ³ para que lo tengan a la mano
[07/09/22, 15:32:03] Mikel Barajas: Muchas gracias
[07/09/22, 15:32:14] Mikel Barajas: Hay que escribir nuestro nombre
[07/09/22, 15:32:18] Mikel Barajas: Para tenerlo de una vez
[07/09/22, 15:32:20] Mikel Barajas: Por apellidos
[07/09/22, 15:32:22] Mikel Barajas: Empiezo yo
[07/09/22, 15:32:53] Mikel Barajas: Nombre: Barajas MarÃ­nes Mikel Ignacio
[07/09/22, 15:33:05] Mikel Barajas: Lo de nombre es para buscarlo mÃ¡s rÃ¡pido por chat
[07/09/22, 15:33:45] Montserrat Gallegos: HernÃ¡ndez Gallegos Montserrat Ximena
[07/09/22, 15:33:50] Raul Moreno: Cerda Moreno Carlos Raul
[07/09/22, 15:35:49] â€ª+52Â 444Â 285Â 9212â€¬: Ola
[07/09/22, 15:37:04] â€ª+52Â 444Â 380Â 2885â€¬: Abarca CÃ¡rcamo Alan Yahir
[07/09/22, 15:37:27] â€ª+52Â 444Â 285Â 9212â€¬: Ojeda GutiÃ©rrez Fernando Juriel
[07/09/22, 15:43:09] â€ª+52Â 444Â 374Â 1420â€¬: HernÃ¡ndez Guerrero Sergio AndrÃ©s
[07/09/22, 15:43:52] Alfredo VillaseÃ±or: VillaseÃ±or MonsivÃ¡is Alfredo
[07/09/22, 16:03:32] â€ª+52Â 444Â 136Â 6505â€¬: Rojas MartÃ­nez Jorge Ãngel
[07/09/22, 16:39:57] Kevin MÃ¡rquez: Marquez Guerrero Kevin
[07/09/22, 17:35:37] â€ª+52Â 444Â 718Â 5474â€¬: HernÃ¡ndez Salazar Isaih Roberto
[07/09/22, 21:37:29] â€ª+52Â 444Â 718Â 5474â€¬: Como propuesta para hacer los cÃ³digos les recomiendo que antes de programar cualquier cosa definamos el algoritmo en una especie de pseudocÃ³digo y veamos si el algoritmo es correcto, para que a la hora de programar haya los menos errores y problemas posibles
[07/09/22, 21:38:04] â€ª+52Â 444Â 285Â 9212â€¬: Si profe
[07/09/22, 21:38:12] â€ª+52Â 444Â 718Â 5474â€¬: CrÃ©anme, cuando lleguen a ED2 o a Algoritmos y Complejidad esto les va servir :3
[07/09/22, 21:40:31] â€ª+52Â 444Â 285Â 9212â€¬: Creo que todos ya vamos en ED2 no?
[07/09/22, 21:50:12] â€+52 444 285 9212 aÃ±adiÃ³ a â€ª+52Â 444Â 887Â 5251â€¬
[07/09/22, 21:40:38] â€ª+52Â 444Â 718Â 5474â€¬: xd
[07/09/22, 21:40:42] â€ª+52Â 444Â 718Â 5474â€¬: No todos
[07/09/22, 21:40:53] â€ª+52Â 444Â 718Â 5474â€¬: Conozco unos que van en Pensamiento avrdd
[07/09/22, 21:40:54] â€ª+52Â 444Â 718Â 5474â€¬: xd
[07/09/22, 21:41:01] â€ª+52Â 444Â 718Â 5474â€¬: Por cierto
[07/09/22, 21:41:09] â€ª+52Â 444Â 718Â 5474â€¬: Falta un chavo
â€[07/09/22, 21:41:29] â€ª+52Â 444Â 718Â 5474â€¬: â€Tarjeta de contacto omitida
[07/09/22, 21:42:46] Kevin MÃ¡rquez: Pero no se supone que el profe vera el chat del grupo para ver todo el avance dela tarea
[07/09/22, 21:43:31] â€ª+52Â 444Â 718Â 5474â€¬: Ah si pero pues para que lo hagamos aquÃ­ tambiÃ©n
[07/09/22, 21:43:40] â€ª+52Â 444Â 285Â 9212â€¬: @5214441190036 dame admin
â€[07/09/22, 21:43:57] â€ª+52Â 444Â 718Â 5474â€¬: â€audio omitido
[07/09/22, 21:45:29] Kevin MÃ¡rquez: O hacer un diagrama de flujo
[07/09/22, 21:49:43] Raul Moreno: Yo tambiÃ©n digo que estÃ¡ bien eso, analizar los problemas antes de hacerlos siempre ayuda
[07/09/22, 22:00:39] Kevin MÃ¡rquez: Estuve leyendo el programa y pide 7 cosas diferentes, propongo que nos dividamos  las 7 actividades, y luego ver si entre esas 7 hay una parte de algoritmo en comun para luego resumirlo
[07/09/22, 22:01:30] Mikel Barajas: Me parece bien lo de dividir
[07/09/22, 22:01:36] Mikel Barajas: Son 7 problemas mÃ¡s el menÃº
[07/09/22, 22:01:40] â€ª+52Â 444Â 718Â 5474â€¬: Hay que ir viendo porque hay algunos que realmente estÃ¡n muy fÃ¡ciles man
[07/09/22, 22:01:40] Mikel Barajas: En total 8 cosas
[07/09/22, 22:01:55] â€ª+52Â 444Â 718Â 5474â€¬: Por ejemplo el Factorial es un ciclo nada mÃ¡s
[07/09/22, 22:02:11] Mikel Barajas: Propongo que cada problema lo tengamos en su propia funciÃ³n y solo lo llamemos desde el menÃº
[07/09/22, 22:02:25] â€ª+52Â 444Â 718Â 5474â€¬: Smn x2
[07/09/22, 22:02:32] â€ª+52Â 444Â 718Â 5474â€¬: Yo tengo un menÃº a ver que les parece
[07/09/22, 22:02:37] â€ª+52Â 444Â 718Â 5474â€¬: O sea de programas anteriores
[07/09/22, 22:02:48] Mikel Barajas: PodrÃ­as mandarlo como un recurso
[07/09/22, 22:02:55] â€ª+52Â 444Â 718Â 5474â€¬: Si voy
[07/09/22, 22:03:00] Mikel Barajas: Solo quÃ© hay que ponernos de acuerdo en convenciones de cÃ³digo
[07/09/22, 22:03:13] â€ª+52Â 444Â 718Â 5474â€¬: int main()
{
	system("color 0A");
    NODO *cab=NULL, *aux;
    int dato;
    int opcion;

	do
    {
    	printf("\n |-----------------LISTAS SIMPLES ENLAZADAS-----------------|");
		printf("\n |1. Insertar al Inicio              5. Eliminar Final      |");
		printf("\n |2. Insertar al Final               6. Buscar y Eliminar   |");
		printf("\n |3. Insertar Ordenado               7. Mostrar Lista	      |");
		printf("\n |4. Elimina Inicio                  8. Salir               |");
		printf("\n |----------------------------------------------------------|");
		printf("\n\n\t Elige una opcion: ");
		scanf("%d",&opcion);

    	switch(opcion)
    	{
    		case 1:
    			printf("\n Insercion al inicio");
				printf("\n Ingresa el dato: ");
				scanf("%d",&dato);
    			InsertaInicio(&cab, dato);
    			break;
    		case 2:
    			printf("Insercion al Final");
    			printf("\n Ingresa el dato: ");
				scanf("%d",&dato);
    			insertaFinal(&cab, dato);
    			break;
    		case 3:
    			printf("Insercion Ordenada");
    			printf("\n Ingresa el dato: ");
				scanf("%d",&dato);
				insertaOrdenadoRec(&cab, dato);
    			break;
    		case 4:
    			printf("Elimina Inicio");
				eliminaInicio(&cab);
    			break;
    		case 5:
    			printf("Elimina Final");
				eliminaFinalRec(&cab);
    			break;
    		case 6:
    			printf("Buscar y Eliminar");
    			printf("\n Dato a eliminar: ");
    			scanf("%d",&dato);
    			eliminaDatoBuscadoRec(&cab, dato);
    		case 7:
    			printf("Mostrar Lista \n");
    			imprimeListaRec(cab);
    			break;
    		case 8:
    			printf("PROGRAMA ELABORADO POR ISAIH HERNANDEZ IsaGamesInc.");
    			break;
		}
	}while(opcion < 8);
	
	liberaLista(&cab);
    
    return 0;
}
[07/09/22, 22:03:23] Mikel Barajas: Como si vamos a usar camelCase o snake_case
[07/09/22, 22:03:37] â€ª+52Â 444Â 718Â 5474â€¬: Queseso? xdd
[07/09/22, 22:03:40] Mikel Barajas: En quÃ© idioma vamos a tener nuestras variables
[07/09/22, 22:03:49] Mikel Barajas: CÃ³mo le llamamos a las variables
[07/09/22, 22:03:53] â€ª+52Â 444Â 718Â 5474â€¬: a
[07/09/22, 22:03:56] Mikel Barajas: AsÃ­ como puse el nombre serÃ­a el estilo
[07/09/22, 22:04:14] â€ª+52Â 444Â 718Â 5474â€¬: Pues una vez un primo que ya es inge me regaÃ±Ã³ por no tener los nombres completos de las varibales
[07/09/22, 22:04:19] Mikel Barajas: TambiÃ©n de quÃ© nombres le pondremos
[07/09/22, 22:04:27] Mikel Barajas: Yo propongo que sean significativos
[07/09/22, 22:04:28] â€ª+52Â 444Â 718Â 5474â€¬: Y me dijo que lo principal en una variable es que tenga el nombre completo
[07/09/22, 22:04:31] Mikel Barajas: Y quÃ© queden largos
[07/09/22, 22:04:33] Mikel Barajas: SÃ­
[07/09/22, 22:04:35] â€ª+52Â 444Â 718Â 5474â€¬: Por lo general yo no uso i
[07/09/22, 22:04:39] â€ª+52Â 444Â 718Â 5474â€¬: Le pongo contador
[07/09/22, 22:04:49] Mikel Barajas: TambiÃ©n hay que ver eso
[07/09/22, 22:04:57] Mikel Barajas: Pero pues por votaciÃ³n
[07/09/22, 22:04:58] â€ª+52Â 444Â 718Â 5474â€¬: Yo propongo que nombres completos
[07/09/22, 22:05:08] Mikel Barajas: Yo digo que divÃ­danos maÃ±ana bien eso
[07/09/22, 22:05:10] â€ª+52Â 444Â 718Â 5474â€¬: Porque luego vamos a batallar con eso si lo modificamos
[07/09/22, 22:05:13] Mikel Barajas: Por orden alfabÃ©tico cada problema
[07/09/22, 22:05:27] â€ª+52Â 444Â 718Â 5474â€¬: Y ademÃ¡s, podrÃ­amos usar la descripciÃ³n del grupo para programar
[07/09/22, 22:05:34] Mikel Barajas: Y decidimos las convenciones de cÃ³digo
[07/09/22, 22:05:36] Kevin MÃ¡rquez: Por eso digo, que al final hagamos comparaciÃ³n para ver quÃ© cambios o resÃºmenes hacer del cÃ³digo
[07/09/22, 22:05:39] â€ª+52Â 444Â 718Â 5474â€¬: AsÃ­ nos permite a todos modificar sin perder lo demÃ¡s
[07/09/22, 22:05:45] Mikel Barajas: Puede ser
[07/09/22, 22:05:57] Mikel Barajas: Solo que no sÃ© si lo dejÃ©
[07/09/22, 22:06:03] Mikel Barajas: Por quÃ© no se guarda en el chat
[07/09/22, 22:06:18] â€â€ª+52Â 444Â 718Â 5474â€¬ cambiÃ³ la descripciÃ³n del grupo
[07/09/22, 22:06:27] Mikel Barajas: Y supongo que el propÃ³sito de hacer la comunicaciÃ³n solo por aquÃ­ es que se tenga guardado todo lo que hicimos
[07/09/22, 22:06:52] â€ª+52Â 444Â 718Â 5474â€¬: TambiÃ©n como que por dÃ­a podemos mandar un resumen completo como copia de seguridad
[07/09/22, 22:07:09] â€ª+52Â 444Â 718Â 5474â€¬: A las 12am que alguien copie lo que haya en la descripciÃ³n y lo manda aquÃ­ a la conver
[07/09/22, 22:07:17] â€ª+52Â 444Â 718Â 5474â€¬: Para no perder en caso de que algo suceda
[07/09/22, 22:07:19] â€ª+52Â 444Â 718Â 5474â€¬: ;v
[07/09/22, 22:07:26] â€ª+52Â 444Â 718Â 5474â€¬: Mark Zuckerberg es impredecible
[07/09/22, 22:07:37] â€ª+52Â 444Â 718Â 5474â€¬: Nomas le mueve poquito y tira wp
[08/09/22, 11:09:29] â€â€ª+52Â 444Â 193Â 2391â€¬ se uniÃ³ usando el enlace de invitaciÃ³n de este grupo
[10/09/22, 13:20:02] Mikel Barajas: Hola equipos
[10/09/22, 13:20:07] Mikel Barajas: Ahora sÃ­ hay que dividir los programas
[10/09/22, 13:20:23] Mikel Barajas: Quieren elegir cada quien su parte, o solo lo asignamos por orden alfabÃ©tico
[10/09/22, 13:21:38] â€ª+52Â 444Â 285Â 9212â€¬: Cualquiera de las dos estarÃ­a bien desde mi humilde opiniÃ³n
â€[10/09/22, 13:21:38] â€ª+52Â 444Â 285Â 9212â€¬: â€sticker omitido
[10/09/22, 13:21:56] â€ª+52Â 444Â 718Â 5474â€¬: Yo elijo el main y el factorial
[10/09/22, 13:22:16] Mikel Barajas: Somos 12
[10/09/22, 13:22:27] Mikel Barajas: Ocupamos solo una parte cada uno
[10/09/22, 13:23:05] Raul Moreno: Yo creo que por orden alfabÃ©tico para que asÃ­ no haya problemas porque a alguien le toco el mÃ¡s fÃ¡cil
[10/09/22, 13:23:42] â€ª+52Â 444Â 718Â 5474â€¬: El main pues
[10/09/22, 13:25:50] Mikel Barajas: Miren
[10/09/22, 13:25:58] Mikel Barajas: Ya despuÃ©s de consultar bien los problemas
[10/09/22, 13:26:23] Mikel Barajas: Me parece que del b) al f) son mÃ¡s implicados
[10/09/22, 13:26:29] Mikel Barajas: Entonces ocuparÃ­an dos personas cada uno
[10/09/22, 13:26:42] Mikel Barajas: Y el a) y el g) son mÃ¡s simples
[10/09/22, 13:26:47] Mikel Barajas: Entonces con una sola persona se puede
[10/09/22, 13:27:14] Mikel Barajas: Vamos a formar parejas para esos 5 problemas
[10/09/22, 13:27:19] Mikel Barajas: Y asÃ­ ya tenemos algo los 12
[10/09/22, 13:27:37] Mikel Barajas: TambiÃ©n estoy de acuerdo con esto
[10/09/22, 13:27:38] Mikel Barajas: Ahora
[10/09/22, 13:27:51] Mikel Barajas: Las parejas las quieren formar asÃ­ tambiÃ©n?
[10/09/22, 13:28:02] Mikel Barajas: O eso si lo hacemos eligiendo?
[10/09/22, 13:28:20] Mikel Barajas: Y estÃ¡n de acuerdo con esta manera de hacerlo?
[10/09/22, 13:30:22] Montserrat Gallegos: Sip estÃ¡ bien
[10/09/22, 13:30:32] Alfredo VillaseÃ±or: Me parece bien
[10/09/22, 13:43:24] Mikel Barajas: Ya van 7 votos
[10/09/22, 13:43:31] Mikel Barajas: Contando mensajes y pulgares arriba
[10/09/22, 13:43:41] Mikel Barajas: Pasen su nombre por apellidos por favor
[10/09/22, 13:43:47] Mikel Barajas: Para ir haciendo una lista
[10/09/22, 13:43:54] â€ª+52Â 444Â 718Â 5474â€¬: Ah caray estamos votando?
[10/09/22, 13:43:55] â€ª+52Â 444Â 718Â 5474â€¬: xdd
[10/09/22, 13:43:58] Mikel Barajas: Por mientras tambiÃ©n cada quien piense en quÃ© convenciones de cÃ³digo
[10/09/22, 13:44:02] â€ª+52Â 444Â 285Â 9212â€¬: Ojeda GutiÃ©rrez Fernando Juriel ğŸ¤™ğŸ½
[10/09/22, 13:44:11] â€ª+52Â 444Â 285Â 9212â€¬: EstÃ¡bamos, ya gano la votaciÃ³n
[10/09/22, 13:44:12] Mikel Barajas: Pues es que 7 estÃ¡n de acuerdo
[10/09/22, 13:44:16] Mikel Barajas: Ya con eso es mayorÃ­a
[10/09/22, 13:44:20] â€ª+52Â 444Â 718Â 5474â€¬: HenÃ¡ndez Salazar Isaih Roberto
[10/09/22, 13:44:27] Montserrat Gallegos: HernÃ¡ndez Gallegos Montserrat Ximena
[10/09/22, 13:44:30] â€ª+52Â 444Â 193Â 2391â€¬: Salazar Rico Diego IsaÃ­:)
[10/09/22, 13:44:32] â€ª+52Â 444Â 718Â 5474â€¬: Jjaja si pero no avisaste eso xd
[10/09/22, 13:45:07] Mikel Barajas: Si alguna vez quieren cambiar algo
[10/09/22, 13:45:09] Mikel Barajas: Digan
[10/09/22, 13:45:14] Mikel Barajas: Por eso siempre pregunto si estÃ¡n de acuerdo
[10/09/22, 13:45:49] â€ª+52Â 444Â 887Â 5251â€¬: Yo puedo hacer lo del factorial?
[10/09/22, 13:46:41] Mikel Barajas: Quienes prefieren trabajar solos, en lugar de por pareja?
[10/09/22, 13:46:42] â€ª+52Â 444Â 887Â 5251â€¬: Rodriguez Perez JosÃ© Rogelio
[10/09/22, 13:47:27] â€ª+52Â 444Â 887Â 5251â€¬: Yo en mi caso si se puede solo
[10/09/22, 13:47:28] Mikel Barajas: Para ver a quiÃ©n le va a tocar el primero y el Ãºltimo
[10/09/22, 13:48:48] Alfredo VillaseÃ±or: VillaseÃ±or MonsivÃ¡is Alfredo
[10/09/22, 13:49:32] Raul Moreno: Cerda moreno Carlos Raul
[10/09/22, 13:49:51] Montserrat Gallegos: Yo uno de esos
[10/09/22, 13:51:56] Mikel Barajas: Ya van dos
[10/09/22, 13:52:04] Mikel Barajas: Si nadie mÃ¡s quiere ellos dos les tocarÃ­a
[10/09/22, 13:52:10] Mikel Barajas: Si alguien quiere diga por aquÃ­
[10/09/22, 13:52:15] Mikel Barajas: Y nos ponemos de acuerdo
[10/09/22, 13:52:35] Mikel Barajas: Mientras estÃ¡ la lista vayan pensando en quÃ© convenciones podrÃ­amos usar y mÃ¡s de rato lo decidimos
[10/09/22, 13:52:53] â€ª+52Â 444Â 887Â 5251â€¬: Yo el g)
[10/09/22, 13:52:58] Mikel Barajas: Y si hay dos personas que quieren trabajar juntos, sÃ­ se puede
[10/09/22, 13:53:19] Mikel Barajas: AsÃ­ no es solo lo que te toca y ya
[10/09/22, 13:53:31] â€ª+52Â 444Â 718Â 5474â€¬: Igual el c) estÃ¡ fÃ¡cil man, si quieres ese yo lo hago solo
[10/09/22, 13:53:35] Mikel Barajas: Los que no tengan problema pues nomÃ¡s les asignamos algo
[10/09/22, 13:53:57] Montserrat Gallegos: El a)
[10/09/22, 13:53:59] â€ª+52Â 444Â 193Â 2391â€¬: Alguien podrÃ­a mandarme ss de los incisos? Es que fui agregado mÃ¡s tarde al grupo:)
[10/09/22, 13:54:08] Mikel Barajas: Pero es tambiÃ©n para que trabajemos todos, en equipo
[10/09/22, 13:54:11] Mikel Barajas: Bueno al menos siento eso
[10/09/22, 13:54:13] â€ª+52Â 444Â 718Â 5474â€¬: Digo porque dices que del b al f estÃ¡n como para 2 personas
[10/09/22, 13:54:21] â€ª+52Â 444Â 718Â 5474â€¬: Entonces pues el c no estÃ¡ tan para dos personas
[10/09/22, 13:54:48] Mikel Barajas: El e) tampoco es tan largo
â€[10/09/22, 13:54:50] â€ª+52Â 444Â 718Â 5474â€¬: â€imagen omitida
[10/09/22, 13:54:59] â€ª+52Â 444Â 718Â 5474â€¬: Esos son los incisos
[10/09/22, 13:55:01] Mikel Barajas: Pero asÃ­ ya quedamos los 12 trabajando
[10/09/22, 13:55:14] Mikel Barajas: A menos que pues tÃº hagas ese
[10/09/22, 13:55:21] Mikel Barajas: Y el que hubiera sido tu pareja el main
[10/09/22, 13:55:34] Mikel Barajas: Solo que ocupamos a alguien mÃ¡s que quiera trabajar solo
[10/09/22, 13:55:52] â€ª+52Â 444Â 718Â 5474â€¬: .
[10/09/22, 13:56:17] Mikel Barajas: Entonces por que no tÃº el main?
[10/09/22, 13:56:32] Mikel Barajas: Y otro el c)
[10/09/22, 13:56:36] â€ª+52Â 444Â 718Â 5474â€¬: Pues si quieres lo diseÃ±o mejor y ahorita lo mando
[10/09/22, 13:56:39] Mikel Barajas: EstÃ¡ bien?
[10/09/22, 13:56:42] â€ª+52Â 444Â 718Â 5474â€¬: Y que alguien mÃ¡s haga el c
[10/09/22, 13:56:45] â€ª+52Â 444Â 718Â 5474â€¬: Smn
[10/09/22, 13:56:47] Mikel Barajas: Va
[10/09/22, 13:57:07] Mikel Barajas: NomÃ¡s falta quien quiera hacer el c) solo
[10/09/22, 13:57:29] â€ª+52Â 444Â 285Â 9212â€¬: Yo lo hago ğŸ«¶ğŸ¼
[10/09/22, 13:57:35] Mikel Barajas: Ya estÃ¡
[10/09/22, 13:57:37] Mikel Barajas: Entonces
[10/09/22, 13:58:30] Mikel Barajas: @5214871594881 @5214447185474 @5214448875251 y @5214442859212 trabajan solos
[10/09/22, 13:58:34] Mikel Barajas: Los demÃ¡s hacemos pareja
[10/09/22, 13:59:41] Mikel Barajas: Dejen llego a mi casa y mando una propuesta de lista de convenciÃ³n
[10/09/22, 13:59:47] Mikel Barajas: Vayan pensando en otras ustedes tambiÃ©n
[10/09/22, 13:59:56] Mikel Barajas: Y hacemos una final
[10/09/22, 14:00:07] Mikel Barajas: O si quieren cambiar alguna de las que mande tambiÃ©n digan
[10/09/22, 14:00:11] Mikel Barajas: Pero todo por aquÃ­
[10/09/22, 14:00:55] Mikel Barajas: Mientras llego por favor manden su nombre los que aÃºn no lo mandan
[10/09/22, 14:01:10] â€ª+52Â 444Â 136Â 6505â€¬: Rojas MartÃ­nez Jorge Ãngel
[10/09/22, 14:01:26] Mikel Barajas: Me parece son @5214443163254 @5214441366505 @5214443802885 y @5214443741420
[10/09/22, 14:01:27] Mikel Barajas: Creo
[10/09/22, 14:01:31] Mikel Barajas: Uno menos
[10/09/22, 14:02:05] â€ª+52Â 444Â 380Â 2885â€¬: No puedo contestar ahorita, estoy en clase
Cuando llegue a mi casa contesto
[10/09/22, 14:03:43] Mikel Barajas: Pasa tu nombre por apellidos
[10/09/22, 14:07:03] â€ª+52Â 444Â 380Â 2885â€¬: Abarca CÃ¡rcamo Alan Yahir
[10/09/22, 14:10:31] â€ª+52Â 444Â 136Â 6505â€¬: Entonces como quedaron?
[10/09/22, 14:10:35] â€ª+52Â 444Â 136Â 6505â€¬: Que me toca a mÃ­?
[10/09/22, 14:13:53] â€ª+52Â 444Â 718Â 5474â€¬: Traer las bebidas
[10/09/22, 14:13:55] â€ª+52Â 444Â 718Â 5474â€¬: Avd
[10/09/22, 14:13:55] â€ª+52Â 444Â 718Â 5474â€¬: XD
[10/09/22, 14:23:41] â€ª+52Â 444Â 374Â 1420â€¬: HernÃ¡ndez Guerrero Sergio AndrÃ©s
[10/09/22, 15:16:17] Mikel Barajas: Ya lleguÃ© a mi casa
[10/09/22, 15:16:35] Mikel Barajas: Oigan hay problema si nomÃ¡s asignÃ³ las parejas aleatoriamente?
[10/09/22, 15:22:12] Mikel Barajas: Miren
[10/09/22, 15:22:19] Mikel Barajas: Esta es mi propuesta de convenciones
[10/09/22, 15:22:38] Mikel Barajas: *Convenciones de Mensajes*

â€¢Incluir asunto al principio del mensaje.
â€¢Etiquetar a las personas involucradas en el mensaje.
â€¢Si se esta respondiendo a un mensaje ya enviado, usar la funciÃ³n de responder mensaje de whatsapp.

_Ejemplo:_

*Asunto*
@nombre1 @nombre2

Hola, creo queâ€¦ (texto del mensaje)
[10/09/22, 15:22:59] Mikel Barajas: *Convenciones de cÃ³digo*

_Naming Conventions (nombres de variables y funciones)_
â€¢Nombres en InglÃ©s.
â€¢Nombres significativos, aunque queden largos.
â€¢Usar snake_case (ejemplo: variable_name).
â€¢Usar i, j, y k como contadores dentro de los ciclos.
â€¢Declarar variables cuando sea necesario (no todas al inicio).

_Funciones_
â€¢Incluir prototipos de las funciones.
â€¢Hacer una funciÃ³n *void* que serÃ¡ llamada desde el menÃº, y que maneje las entradas y salidas.
â€¢Hacer otras funciones si se requiere un proceso mÃ¡s complejo, que se llame desde la funcion anterior.

_Entradas y salidas (scanf, printf)_
â€¢Mensajes en espaÃ±ol.
â€¢*No* escribir los mensajes a manera de pregunta. (Ejemplo: "Â¿CuÃ¡l es la escala de temperatura?")
â€¢Si una entrada tiene opciones especÃ­ficas, imprimirlas entre corchetes.
    Â·Ejemplos:
    Â·"Confirmar operaciÃ³n [Y/N]:"
    Â·Escala de temperatura [C, F, R]: "

_Comentarios_
â€¢Todas las funciones deben ir comentadas.
[10/09/22, 15:25:06] Mikel Barajas: *Tareas*

â€¢*Main:* Isaih @5214447185474
â€¢*a) Bisiesto:* Montse @5214871594881
â€¢*b) DÃ­as:* Raul @5214441190036 Joe @5214441366505
â€¢*c) Temperatura:* Fernando @5214442859212
â€¢*d) Edades:* Alan @5214443802885 Alfredo @5214442145259
â€¢*e) TrigonometrÃ­a:*  Sergio @5214443741420 Kevin @5214443163254
â€¢*f) EstadÃ­stica:* Mikel @yo IsaÃ­ @5214441932391
â€¢*g) Factorial:* Rogelio @5214448875251
[10/09/22, 15:25:15] Mikel Barajas: QuÃ© les parece?
[10/09/22, 15:25:45] Mikel Barajas: IntentÃ© respetar a los que les tocÃ³ juntos en la primera tarea segÃºn
[10/09/22, 15:25:59] Mikel Barajas: Denle like si estÃ¡n de acuerdo
[10/09/22, 15:26:38] Mikel Barajas: *desacuerdos*

Si quisieran cambiar algo, respondan el mensaje de la convenciÃ³n y digan que cambiarÃ­an, y por quÃ©.
[10/09/22, 15:27:03] Mikel Barajas: *otras propuestas*
Si quieren proponer otras convenciones por completo, envÃ­en una lista y eso
[10/09/22, 15:27:09] â€ª+52Â 444Â 718Â 5474â€¬: Unos cuantos detallitos que de hecho iba a proponer, no como desacuerdo
[10/09/22, 15:27:10] â€ª+52Â 444Â 718Â 5474â€¬: Pero
[10/09/22, 15:27:15] â€ª+52Â 444Â 718Â 5474â€¬: Si para checar
[10/09/22, 15:27:19] â€ª+52Â 444Â 718Â 5474â€¬: Ah, justo eso dd
[10/09/22, 15:27:59] Mikel Barajas: Solo ponlas con el formato de mensaje
[10/09/22, 15:28:12] Mikel Barajas: Si es de agregar, las agrego al mensaje despuÃ©s
[10/09/22, 15:28:20] Mikel Barajas: Por ahora creo podemos empezar
[10/09/22, 15:28:53] Mikel Barajas: QuÃ© les parece tener cada parte por separado para maÃ±ana a las 3pm?
[10/09/22, 15:29:07] Mikel Barajas: Para que le dÃ© tiempo a @5214447185474 de conectarlo todo
[10/09/22, 15:29:14] Mikel Barajas: Y ver los detalles que surjan
[10/09/22, 15:29:49] â€ª+52Â 444Â 718Â 5474â€¬: Antes de comenzar con lo de propuestas y eso, para que veas el main prototipo de como queda, para resolver cosas como lo de paso de parametros, etc
[10/09/22, 15:29:52] â€ª+52Â 444Â 718Â 5474â€¬: int main()
{
	int opcion;

	do
    {
    	printf("\n |------------------PROGRAMA FORMULAS 2022------------------|");
		printf("\n |1. BISIESTO                         5. TRIGONOMETRIA      |");
		printf("\n |2. DIAS PARA LLEGAR A UNA FECHA     6. ESTADISTICA        |");
		printf("\n |3. TEMPERATURA                      7. FACTORIAL	      |");
		printf("\n |4. EDADES                           8. SALIR              |");
		printf("\n |----------------------------------------------------------|");
		printf("\n\n Elige una opcion: ");
		scanf("%d",&opcion);

    	switch(opcion)
    	{
    		case 1:
    			printf("\n BISIESTO");
    			break;
    		case 2:
    			printf("\n DIAS PARA LLEGAR A UNA FECHA");
    			break;
    		case 3:
    			printf("\n TEMPERATURA");
    			break;
    		case 4:
    			printf("\n EDADES");
    			break;
    		case 5:
    			printf("\n TRIGONOMETRIA");
    			break;
    		case 6:
    			printf("\n ESTADISTICA");
    			break;
    		case 7:
    			printf("\n FACTORAIL");
    			break;
    		case 8:
    			break;
    		default:
    			printf("\n NO EXISTE");
		}
	}while(opcion != 8);
    
    return 0;
}
[10/09/22, 15:29:58] â€ª+52Â 444Â 718Â 5474â€¬: Ese es el main prototipo
[10/09/22, 15:30:19] â€ª+52Â 444Â 718Â 5474â€¬: En cada case habrÃ¡ una funciÃ³n obviamente, la cosa es la siguiente
[10/09/22, 15:30:46] â€ª+52Â 444Â 718Â 5474â€¬: Necesito que en las funciones me especifiquen si lo estÃ¡n mandando por parÃ¡metro o por retorno
[10/09/22, 15:30:54] â€ª+52Â 444Â 718Â 5474â€¬: Para asÃ­ saber quÃ© variables necesito
[10/09/22, 15:31:00] â€ª+52Â 444Â 718Â 5474â€¬: Y otra cosilla
[10/09/22, 15:31:09] Raul Moreno: Yo no puedo jajaja, estoy trabajando ahorita, salgo a las 11 y maÃ±ana entro a 8 y salgo a las 4
[10/09/22, 15:31:22] Mikel Barajas: Yo pensaba que mejor solo se llamara un void, y que cada problema contara con su â€œmainâ€
[10/09/22, 15:31:34] Mikel Barajas: AsÃ­ cada persona maneja variables, entradas y salidas
[10/09/22, 15:31:42] Mikel Barajas: Y asÃ­ nos evitamos tener que organizar parÃ¡metros
[10/09/22, 15:31:50] Mikel Barajas: AsÃ­ hasta podrÃ­a verse mÃ¡s limpio el main
[10/09/22, 15:31:55] â€ª+52Â 444Â 718Â 5474â€¬: Hay algunas variables que podrÃ­an resultar repetitivas, entonces aquÃ­ si *propuesta* que definamos una sola variable a usar para ciertas funciones
[10/09/22, 15:32:31] â€ª+52Â 444Â 718Â 5474â€¬: Ah o sea, cada funciÃ³n tendrÃ¡ lo suyo, el menÃº solo es para mandar a llamar la funciÃ³n
[10/09/22, 15:32:35] Mikel Barajas: SÃ­
[10/09/22, 15:32:39] Mikel Barajas: AsÃ­ es mÃ¡s fÃ¡cil revisarla
[10/09/22, 15:32:59] Mikel Barajas: No tienes que saltar tanto de funciÃ³n a funciÃ³n mientras ves que es lo que hace
[10/09/22, 15:33:03] â€ª+52Â 444Â 718Â 5474â€¬: Bueno, igual si llego a ver inconsistencias con los nombre de variable yo lo analizo
[10/09/22, 15:33:07] Mikel Barajas: Va
[10/09/22, 15:33:45] â€ª+52Â 444Â 718Â 5474â€¬: Ya estÃ¡, por lo pronto tengo el main base del menÃº y como vayamos avanzando pues a ver quÃ© rollo
[10/09/22, 15:34:18] Mikel Barajas: Bueno, en tu caso nomÃ¡s que le vaya avanzando el otro de tu equipo
[10/09/22, 15:34:25] â€ª+52Â 444Â 193Â 2391â€¬: Lo que podemos hacer es que cuando mandemos las funciones hechas, revisemos quÃ© variables se repiten en varias y solo esas las hacemos globales
[10/09/22, 15:34:32] â€ª+52Â 444Â 193Â 2391â€¬: Y que el resto funcionen en su propio bloque
[10/09/22, 15:34:33] Mikel Barajas: Y con tener el nombre de la funciÃ³n podemos seguirle
[10/09/22, 15:34:45] Mikel Barajas: Yo creo que mejor no hay que usar ninguna variable global
[10/09/22, 15:34:47] â€ª+52Â 444Â 718Â 5474â€¬: Ya eso es lo que yo me encargo ntp
[10/09/22, 15:34:59] Mikel Barajas: PodrÃ­amos hacer una struct persona por quÃ© esa se repite varias veces
[10/09/22, 15:35:03] Mikel Barajas: Pero el mismo profe dijo
[10/09/22, 15:35:10] Mikel Barajas: Que era mala idea usar variables globales
[10/09/22, 15:35:17] â€ª+52Â 444Â 718Â 5474â€¬: Ah esa es otra
[10/09/22, 15:35:26] â€ª+52Â 444Â 718Â 5474â€¬: Con lo de las edades
[10/09/22, 15:35:46] â€ª+52Â 444Â 718Â 5474â€¬: Bueno, para cualquier funciÃ³n mejor dicho
[10/09/22, 15:35:59] Raul Moreno: O igual no se si aÃºn se puede cambiar y que me dejen una individual, para no tardar tanto en hacerlo
[10/09/22, 15:36:02] â€ª+52Â 444Â 718Â 5474â€¬: Si hay structs o algo asÃ­, tambiÃ©n mandenlos para agregarlos, nomas especifiquen que onda
[10/09/22, 15:36:29] Mikel Barajas: No hay mucho impacto de memoria si usamos son variables parecidas en varias funciones
[10/09/22, 15:36:31] Mikel Barajas: Va
[10/09/22, 15:36:40] Mikel Barajas: Pregunta por aquÃ­ a los que les tocÃ³ individual
[10/09/22, 15:36:43] Mikel Barajas: Si no te cambian
[10/09/22, 15:36:55] Raul Moreno: @5214442859212  no me cambias?
[10/09/22, 15:37:03] Raul Moreno: Y te hago una pizza
[10/09/22, 15:37:23] â€ª+52Â 444Â 718Â 5474â€¬: Tssss
[10/09/22, 15:37:35] â€ª+52Â 444Â 718Â 5474â€¬: Yo quiero una, pero no cambio, nomas regalamela uwu
[10/09/22, 15:37:37] â€ª+52Â 444Â 718Â 5474â€¬: JAJAJA
[10/09/22, 15:40:06] Mikel Barajas: *Convenciones de Mensajes*

â€¢Incluir asunto al principio del mensaje.
â€¢Etiquetar a las personas involucradas en el mensaje.
â€¢Si se esta respondiendo a un mensaje ya enviado, usar la funciÃ³n de responder mensaje de whatsapp.

_Ejemplo:_

*Asunto*
@nombre1 @nombre2

Hola, creo que (texto del mensaje)

*Convenciones de cÃ³digo*

_Naming Conventions (nombres de variables y funciones)_
â€¢Nombres en InglÃ©s.
â€¢Nombres significativos, aunque queden largos.
â€¢Usar snake_case (ejemplo: variable_name).
â€¢Usar i, j, y k como contadores dentro de los ciclos.
â€¢Declarar variables cuando sea necesario (no todas al inicio).
â€¢Avisar si van a necesitar usar una struct.
â€¢Usar typedef en structs.
â€¢No variables globales.

_Funciones_
â€¢Incluir prototipos de las funciones.
â€¢Hacer una funciÃ³n *void* que serÃ¡ llamada desde el menÃº, y que maneje las entradas y salidas (Es como un main por cada problema).
â€¢Hacer otras funciones si se requiere un proceso mÃ¡s complejo, que se llame desde la funcion anterior.

_Entradas y salidas (scanf, printf)_
â€¢Mensajes en espaÃ±ol.
â€¢*No* escribir los mensajes a manera de pregunta. (Ejemplo: "Â¿CuÃ¡l es la escala de temperatura?")
â€¢Si una entrada tiene opciones especÃ­ficas, imprimirlas entre corchetes.
    Â·Ejemplos:
    Â·"Confirmar operaciÃ³n [Y/N]:"
    Â·Escala de temperatura [C, F, R]: "

_Comentarios_
â€¢Todas las funciones deben ir comentadas.

*Tareas*

â€¢*Main:* Isaih @5214447185474
â€¢*a) Bisiesto:* Montse @5214871594881
â€¢*b) DÃ­as:* Raul @5214441190036 Joe @5214441366505
â€¢*c) Temperatura:* Fernando @5214442859212
â€¢*d) Edades:* Alan @5214443802885 Alfredo @5214442145259
â€¢*e) TrigonometrÃ­a:*  Sergio @5214443741420 Kevin @5214443163254
â€¢*f) EstadÃ­stica:* Mikel @yo IsaÃ­ @5214441932391
â€¢*g) Factorial:* Rogelio @5214448875251
[10/09/22, 15:40:26] Mikel Barajas: Ya quedÃ³ con lo que dijo isaih de las structs
[10/09/22, 15:40:31] Mikel Barajas: Si es que se ocupan
[10/09/22, 15:40:43] Mikel Barajas: Si hay cambio en las tareas las pongo luego
[10/09/22, 15:41:14] Mikel Barajas: Por mientras ya podemos empezar
[10/09/22, 15:41:16] Mikel Barajas: Ya saben
[10/09/22, 15:41:20] Mikel Barajas: Toda la comunicaciÃ³n por aquÃ­
[10/09/22, 15:43:24] Mikel Barajas: *Problema f) estadÃ­stica*
@5214441932391 

Ando afuera de mi casa, no puedo empezar yo. Puedes ir viendo cÃ³mo que datos podrÃ­amos ir calculando? AsÃ­ como los que saca el INEGI en el censo. Con quÃ© sean  por individuo, no de familias o demÃ¡s.
[10/09/22, 15:44:17] Mikel Barajas: El formato de mensaje es para no perdernos tanto mientras hablan todos los demÃ¡s, asÃ­ nomÃ¡s le damos a cada respuesta para ver de quÃ© trataba originalmente
[10/09/22, 15:49:30] â€ª+52Â 444Â 193Â 2391â€¬: *Problema f) estadÃ­stica*
@5214445027537 
Creo que con â€œpoblaciÃ³nâ€ se refiere a una poblaciÃ³n de datos, no? Por ejemplo dar n datos y de ellos calcular media, mediana y moda. 

Por la complejidad del resto de incisos, no me hace tanta lÃ³gica que se trate de una poblaciÃ³n de personas como tal.  No sÃ© quÃ© opines
[10/09/22, 15:50:24] Mikel Barajas: Primero habÃ­a pensado eso, pero siento que lo dejo amplio para el lunes ya meterle la complejidad
[10/09/22, 15:50:40] Mikel Barajas: Por quÃ© es el mÃ¡s vagamente definido
[10/09/22, 15:51:02] Mikel Barajas: Me parece buena tu idea de primero hacerlo para datos Ãºnicamente, pero hay que preparar por si pide para personas
[10/09/22, 15:51:16] Mikel Barajas: @5214441932391 tambiÃ©n estÃ¡s de acuerdo con primero solo hacerlo de datos nÃºmeros?
[10/09/22, 15:51:48] Mikel Barajas: Yo sÃ­ estoy de acuerdo con @5214447185474 , tiene mÃ¡s sentido que sea de nÃºmeros
[10/09/22, 15:52:07] Mikel Barajas: NomÃ¡s con ver quÃ© sube el lunes
[10/09/22, 15:52:49] â€ª+52Â 444Â 718Â 5474â€¬: Ah caray xdd como como, contexto de quÃ© propuse
[10/09/22, 15:53:05] Mikel Barajas: O sea poblaciÃ³n de datos, no de personas
[10/09/22, 15:53:18] Mikel Barajas: Yo me fui con la finta de que era de personas
[10/09/22, 15:53:42] Mikel Barajas: Pero tiene mÃ¡s sentido lo que tÃº dijiste aquÃ­
[10/09/22, 15:53:54] â€ª+52Â 444Â 193Â 2391â€¬: SÃ­, me parece mejor prepararlo asÃ­ de nÃºmeros y si quieres dejamos preparado un prototipo de lo otro por si acaso ğŸ‘
[10/09/22, 15:54:03] Mikel Barajas: Perfecto
[10/09/22, 15:54:17] Mikel Barajas: Entonces solo ve viendo quÃ© datos podemos calcular
[10/09/22, 15:54:22] Mikel Barajas: Llegando nos dividimos esos
[10/09/22, 15:54:26] â€ª+52Â 444Â 193Â 2391â€¬: Vaqueva
[10/09/22, 15:56:24] Mikel Barajas: Alguien mÃ¡s no puede?
[10/09/22, 15:57:01] Mikel Barajas: @5214441932391 @5214442145259 @5214443163254 @5214871594881 @5214441190036 @5214441366505 @5214442859212 @5214443741420 @5214443802885 @5214447185474 @5214448875251
[10/09/22, 15:57:33] â€ª+52Â 444Â 718Â 5474â€¬: Pues yo por ahora ya tengo lo mÃ­o, ya nada mÃ¡s que vayan haciendo sus funciones pues me las mandan
[10/09/22, 15:58:33] â€ª+52Â 444Â 285Â 9212â€¬: Es que ya elegÃ­ la mÃ­a jejeje ğŸ™ˆ
[10/09/22, 15:59:07] â€ª+52Â 444Â 285Â 9212â€¬: Yo si puedo para maÃ±ana, pero no creo estar en mi casa a las 3, serÃ­a como hasta las 6-7
[10/09/22, 16:00:46] Raul Moreno: Ãndale mejor amigo ferxxo, y te invito un bolis
[10/09/22, 16:00:48] â€ª+52Â 444Â 718Â 5474â€¬: Oigan, como recurso para que prueben sus funciones les dejo este "prototipo" 
int main()
{	
	<nombre de la funcion>; //Basicamente aquÃ­ se pone la funciÃ³n que se probarÃ¡
	return 0;
}
[10/09/22, 16:02:31] â€ª+52Â 444Â 718Â 5474â€¬: *Propuesta*
ProgramaciÃ³n modular, bÃ¡sicamente significa que no usemos paso de parÃ¡metros ni nada de eso si no se requiere ya que no usaremos arreglos dinÃ¡micos ni listas enlazadas, etc.

AsÃ­ en vez de hacer funciones por ejemplo:
int factorial(int numero);

Hacemos funciones como:
void factorial();
[10/09/22, 16:13:56] Mikel Barajas: Solamente que si ocupan una funciÃ³n que calcule un nÃºmero, sÃ­ Ãºsenla
[10/09/22, 16:14:08] Mikel Barajas: Como dice isaih, si se requiere
[10/09/22, 16:14:45] Mikel Barajas: Cada problema serÃ¡ un mÃ³dulo entonces
[10/09/22, 16:18:38] Mikel Barajas: *propuesta*

Validar valores que deben estar en un rango con un ciclo do while
[10/09/22, 16:18:49] Mikel Barajas: Por ejemplo, el tamaÃ±o de un arreglo
[10/09/22, 16:19:41] Mikel Barajas: *propuesta* 
Definir un MAX para el tamaÃ±o del arreglo, por ejemplo 100
[11/09/22, 14:00:55] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036 oye, entonces a quÃ© hora estÃ¡s en tu casa para hacer el programa?
[11/09/22, 14:03:34] Raul Moreno: Estoy disponible a las 5
[11/09/22, 14:03:37] Raul Moreno: Puedes?
[11/09/22, 14:05:06] Mikel Barajas: @5214441932391, quÃ© podemos agregarle a nuestra parte?
[11/09/22, 14:05:16] Mikel Barajas: QuÃ© cÃ¡lculos digo
[11/09/22, 14:05:30] Mikel Barajas: Me imagino pro ahora que media, moda y mediana
[11/09/22, 14:06:32] â€ª+52Â 444Â 136Â 6505â€¬: Smn
[11/09/22, 14:18:28] â€ª+52Â 444Â 380Â 2885â€¬: *Problema d) edades*
@5214442145259 
Â¿EstÃ¡s para hacerlo?
[11/09/22, 14:19:32] Alfredo VillaseÃ±or: Si, apenas me iba a comunicar contigo
[11/09/22, 14:22:43] â€ª+52Â 444Â 380Â 2885â€¬: Â¿Como se te ocurre que podamos hacerlo?
[11/09/22, 14:27:36] Kevin MÃ¡rquez: *e) TrigonometrÃ­a:*  @5214443741420 estÃ¡s listo?
[11/09/22, 14:31:09] Alfredo VillaseÃ±or: Primero que nada, definiendo si pedimos la edad mediante el rol del integrante de la familia.
Ejemplo:
Edad de la madre:

Pero tendrÃ­amos que preguntar si tiene padre, madre y cuÃ¡ntos herman@s, delimitando hasta ahÃ­ la familia o agregando mÃ¡s roles.

Se me hace mÃ¡s sencillo pedirlo como:
Edad integrante 1:

No sÃ© quÃ© opines
[11/09/22, 14:35:45] â€ª+52Â 444Â 374Â 1420â€¬: ya habÃ­a empezado algo, pero me surgiÃ³ la duda de que si pregunta de hacer 3 funciones o elegir de las 3 una
[11/09/22, 14:36:26] â€ª+52Â 444Â 374Â 1420â€¬: o si no de poner de todas tipo seno, coseno, tangente, csc, sec, cot, acos, asen y asÃ­
[11/09/22, 14:36:30] â€ª+52Â 444Â 380Â 2885â€¬: Sip, yo opino lo mismo 
Que pidamos primero cuÃ¡ntos integrantes son y ya despuÃ©s con un ciclo que vaya pidiendo las edades

Edad del integrante 1
Edad del integrante 2
â€¦
[11/09/22, 14:37:52] â€ª+52Â 444Â 380Â 2885â€¬: Y bueno pedir los aÃ±os y los meses
Algo asÃ­ como

AÃ±os del integrante 1
Meses del integrante 2
[11/09/22, 14:37:54] â€ª+52Â 444Â 380Â 2885â€¬: Tal vez
[11/09/22, 14:39:44] Alfredo VillaseÃ±or: ------ EDAD INTEGRANTE 1 ------
AÃ±os:
Meses:
[11/09/22, 14:42:08] Kevin MÃ¡rquez: No, el programa dice solo 3
[11/09/22, 14:42:22] Kevin MÃ¡rquez: Y me imagino que las principales de sen, cos, tan
[11/09/22, 14:43:13] Kevin MÃ¡rquez: X2
[11/09/22, 14:47:42] â€ª+52Â 444Â 374Â 1420â€¬: void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    printf("Ingresa el angulo en radianes: ");
    scanf("%f",&radianes);
    printf("Elige la funcion a realizar:\n");
    printf("1. Seno\n");
    printf("2. Coseno\n");
    printf("3. Tangente\n");
    scanf("%d",&funcion_del_angulo);
    switch(funcion_del_angulo)
    {
        case 1:     //Funcion seno
        resultado=sin(radianes);
        printf("Seno de %f radianes: %f ",radianes,resultado);
        break;
        case 2:     //Funcion coseno
        resultado=cos(radianes);
        printf("Coseno de %f radianes: %f ",radianes,resultado);
        break;
        case 3:     //Funcion tangente
        resultado=tan(radianes);
        printf("Tangente de %f radianes: %f ",radianes,resultado);
        break;
    }
}

si son solo de esas 3 elegir entonces tengo esto, igual y ya viendo bien cambiarle
[11/09/22, 14:49:57] Montserrat Gallegos: *PROBLEMA A*
[11/09/22, 14:50:05] Kevin MÃ¡rquez: Entonces la respuesta serÃ¡ en nÃºmeros?
[11/09/22, 14:50:23] Kevin MÃ¡rquez: Deja veo que le puedo cambiar o mejorar
[11/09/22, 14:50:52] Montserrat Gallegos: *PROBLEMA A*

void is_a_leap_year(){
    int year, leap_year;

    do{
        printf("Ingresa el anio a consultar:\n");
        scanf("%d", &year);
        if(year<0){
            printf("El anio no es valido:\n");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf("El anio SI es bisiesto\n");
    }else{
        printf("El anio NO es bisiesto\n");
    }
}
[11/09/22, 14:51:55] Montserrat Gallegos: Esa es la funciÃ³n que me tocÃ³... Ya la probÃ©, y pues funciona, pero si tengo algo que corregir en cuestiÃ³n de la convenciÃ³n del cÃ³digo me dicen
[11/09/22, 14:52:48] â€ª+52Â 444Â 374Â 1420â€¬: Yo dirÃ­a
[11/09/22, 14:54:16] Kevin MÃ¡rquez: Le agregarÃ© el %.2f para evitar el exceso de decimas, un default al switch para marcarle al usuario que se equivocÃ³ y vuelva a intentar
[11/09/22, 14:54:18] â€ª+52Â 444Â 374Â 1420â€¬: Ok, igual y eso de si sÃ­ son pedir 3 de varias agregarle mÃ¡s opciones al switch y poner un ciclo
[11/09/22, 14:54:26] â€ª+52Â 444Â 374Â 1420â€¬: Ok
[11/09/22, 14:55:44] â€ª+52Â 444Â 380Â 2885â€¬: Yep una struct?
[11/09/22, 14:55:55] â€ª+52Â 444Â 380Â 2885â€¬: Â¿Y para sacar el promedio como se te ocurre?
[11/09/22, 14:56:16] â€ª+52Â 444Â 380Â 2885â€¬: La forma que se me ocurrre es pasar el aÃ±o a meses y sumarlo a los meses y de ahÃ­ sacar el promedio y despuÃ©s pasarlo a aÃ±os de nuevo jaja
[11/09/22, 14:56:30] â€ª+52Â 444Â 380Â 2885â€¬: Pero estÃ¡ muy revoltoso creo, no sÃ© si se te ocurre algo mejor
[11/09/22, 14:59:24] â€ª+52Â 444Â 193Â 2391â€¬: Yo dirÃ­a que con esas tres, la vdd
[11/09/22, 14:59:46] â€ª+52Â 444Â 193Â 2391â€¬: Tan solo en la moda siento que ya es suficiente cÃ³digo, porque tenemos que ir contando cada que se repita un tÃ©rmino
[11/09/22, 15:02:11] Alfredo VillaseÃ±or: Se me ocurriÃ³ de la misma manera
Â¿Y cÃ³mo pasamos la parte decimal del promedio a meses?
Supongo que debemos mostrarlo asÃ­, Â¿no?
[11/09/22, 15:02:31] Kevin MÃ¡rquez: void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    char resp[5];
    do
    {
        printf("Ingresa el angulo en radianes: ");
        scanf("%f",&radianes);
        printf("Elige la funcion a realizar:\n");
        printf("1. Seno\n");
        printf("2. Coseno\n");
        printf("3. Tangente\n");
        scanf("%d",&funcion_del_angulo);
        switch(funcion_del_angulo)
        {
            case 1:     //Funcion seno
                resultado=sin(radianes);
                printf("Seno de %.2f radianes: %.2f ",radianes,resultado);
            break;
            case 2:     //Funcion coseno
                resultado=cos(radianes);
                printf("Coseno de %.2f radianes: %.2f ",radianes,resultado);
            break;
            case 3:     //Funcion tangente
                resultado=tan(radianes);
                printf("Tangente de %.2f radianes: %.2f ",radianes,resultado);
            break;
            default:
                printf("Esa opcion no esta disponible, vuelva a intentar\n");
        }
        printf("Continuar(s/n)");
        gets(resp);
    }while(resp=='s');
}
[11/09/22, 15:06:07] â€ª+52Â 444Â 374Â 1420â€¬: Ya quedÃ³ entonces?
[11/09/22, 15:08:13] Kevin MÃ¡rquez: Solo queda hacerle una prueba rÃ¡pida
[11/09/22, 15:09:02] Kevin MÃ¡rquez: No ando en casa y lo edite en el cel
[11/09/22, 15:21:35] â€ª+52Â 444Â 380Â 2885â€¬: Si
DÃ©jame checarlo y ahorita te enseÃ±o
[11/09/22, 15:46:30] Alfredo VillaseÃ±or: Â¿Debe estar todo dentro de una misma funciÃ³n *void*?
[11/09/22, 15:49:36] Mikel Barajas: No
[11/09/22, 15:49:41] Mikel Barajas: Pueden usar funciones aparte
[11/09/22, 15:49:59] Mikel Barajas: Mejor Ãºsenlas si calculan varias cosas dÃ© hecho
[11/09/22, 15:50:04] Mikel Barajas: No hay que tener funciones gigantes
[11/09/22, 15:54:19] â€ª+52Â 444Â 380Â 2885â€¬: DÃ©jame intentar hacerlo, ahorita te mando mi progreso
[11/09/22, 15:54:31] â€ª+52Â 444Â 285Â 9212â€¬: Hola, tengo un pequeÃ±o problema por asi decirlo. 

printf("Ingresa la escala que estas utilizando[C/F/K]:");
    scanf("%c",&scale);
    printf("Ingresa la temperatura: ");
    scanf("%d",&temperature);
    printf("Ingresa la escala a la que deseas convertirla[C/F/K]:");
    scanf("%c",&option);

Al momento de querer leer el segundo caracter el codigo no me lo lee, he utilizado varios compiladores y el error es el mismo. Ya tengo la funcion hecha, solo me falta esa pequeÃ±a parte para poder completarlo. Alguien sabe por que puede ser?
[11/09/22, 15:56:53] Raul Moreno: Eso pasa por no querer dejÃ¡rmelo
[11/09/22, 15:57:33] Mikel Barajas: Ponle un espacio antes del %c
[11/09/22, 15:57:42] â€ª+52Â 444Â 285Â 9212â€¬: Una disculpa estimado
[11/09/22, 15:57:47] Mikel Barajas: Lo quÃ© pasa es que scanf lee lo que estÃ¡ en el buffer
[11/09/22, 15:58:08] Mikel Barajas: Y cuando le das enter se queda el espacio de â€˜/nâ€™ guardado
[11/09/22, 15:58:18] Mikel Barajas: Y eso pone en la variable option
[11/09/22, 15:58:29] Mikel Barajas: Si pones â€œ %câ€
[11/09/22, 15:58:33] Mikel Barajas: Con un espacio antes
[11/09/22, 15:58:36] Mikel Barajas: En el segundo scanf
[11/09/22, 15:58:39] Mikel Barajas: Ya lo lee bien
[11/09/22, 15:59:14] â€ª+52Â 444Â 285Â 9212â€¬: Ahhhh ya ya, esa no me la sabia. Ya me jalo la funciÃ³n jejej, en un momento la mando, ya solo la complemento
[11/09/22, 15:59:24] â€ª+52Â 444Â 285Â 9212â€¬: Muchas gracias ğŸ«±ğŸ½â€ğŸ«²ğŸ½
[11/09/22, 16:06:46] Raul Moreno: TambiÃ©n pudiste usar la funciÃ³n setbuff despuÃ©s del scanf donde lees el entero
[11/09/22, 16:07:09] Mikel Barajas: *entrega*
Oigan, entonces se entrega el jueves o el martes?
[11/09/22, 16:07:38] Raul Moreno: Yo tambiÃ©n tengo la misma duda, porque lo encargo el martes, pero luego mencionÃ³ que el jueves
[11/09/22, 16:07:52] â€ª+52Â 444Â 380Â 2885â€¬: SegÃºn yo se entrega el jueves
[11/09/22, 16:08:13] Mikel Barajas: Vamos a intentar acabar una versiÃ³n hoy o maÃ±ana
[11/09/22, 16:08:18] Mikel Barajas: Para no presionarnos tanto
[11/09/22, 16:08:22] Mikel Barajas: QuÃ© opinan
[11/09/22, 16:10:20] â€ª+52Â 444Â 380Â 2885â€¬: Yo digo que sip maÃ±ana, sirve que nos actualiza el programa
[11/09/22, 16:14:22] Mikel Barajas: @5214441932391 puedes hacer una funciÃ³n que reciba un arreglo de double y regrese un valor double que sea el promedio?
[11/09/22, 16:14:33] Mikel Barajas: TambiÃ©n recibirÃ­a tamaÃ±o
[11/09/22, 16:14:45] â€ª+52Â 444Â 193Â 2391â€¬: Sip
[11/09/22, 16:16:32] â€ª+52Â 444Â 374Â 1420â€¬: void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    char resp;
    do
    {
        printf("Ingresa el angulo en radianes: ");
        scanf("%f",&radianes);
        printf("Elige la funcion a realizar:\n");
        printf("1. Seno\n");
        printf("2. Coseno\n");
        printf("3. Tangente\n");
        scanf("%d",&funcion_del_angulo);
        switch(funcion_del_angulo)
        {
            case 1:     //Funcion seno
                resultado=sin(radianes);
                printf("Seno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 2:     //Funcion coseno
                resultado=cos(radianes);
                printf("Coseno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 3:     //Funcion tangente
                resultado=tan(radianes);
                printf("Tangente de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            default:
                printf("Esa opcion no esta disponible, vuelva a intentar\n");
        }
        printf("Continuar(s/n)");
        scanf(" %c",&resp);
    }while(resp=='s');
}

ya nada mÃ¡s le cambiÃ© en lugar de cadena un carÃ¡cter y un scan y ya probÃ© y sÃ­ funciona
[11/09/22, 16:17:15] Mikel Barajas: Es con math.h vea?
[11/09/22, 16:17:22] Mikel Barajas: O con cmath?
[11/09/22, 16:17:35] â€ª+52Â 444Â 374Â 1420â€¬: si
[11/09/22, 16:17:41] Mikel Barajas: NomÃ¡s para nosotros usar la misma
[11/09/22, 16:17:43] Mikel Barajas: Gracias
[11/09/22, 16:18:09] Mikel Barajas: Pueden agregar cÃ³mo comentario las librerÃ­as que usen?
[11/09/22, 16:18:57] Mikel Barajas: @5214441932391 @5214442145259 @5214443163254 @5214871594881 @5214441190036 @5214441366505 @5214442859212 @5214443741420 @5214443802885 @5214447185474 @5214448875251
[11/09/22, 16:19:21] Mikel Barajas: Aunque sea el stdio.h
[11/09/22, 16:19:31] Mikel Barajas: Y el stdlib
[11/09/22, 16:19:51] Mikel Barajas: TambiÃ©n denle a destacar su mensaje con la Ãºltima versiÃ³n de la funciÃ³n que les toco
[11/09/22, 16:19:54] Mikel Barajas: Para no perderlas
[11/09/22, 16:23:53] Montserrat Gallegos: *PROBLEMA A*

//PROTOTIPO: 
//void is_a_leap_yesr();

//LIBRERÃAS:
//#include <stdio.h>
//#include <stdlib.h>

//FUNCION:
void is_a_leap_year(){
    int year, leap_year;

    do{
        printf("Ingresa el anio a consultar:\n");
        scanf("%d", &year);
        if(year<0){
            printf("El anio no es valido:\n");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf("El anio SI es bisiesto\n");
    }else{
        printf("El anio NO es bisiesto\n");
    }
}
[11/09/22, 16:40:12] â€ª+52Â 444Â 193Â 2391â€¬: //Esta funciÃ³n calcula el promedio de los datos del arreglo
//<stdio.h>
double average(double arr[], int size){
	double ave=0;
	int i=0;
	for(i; i<size; i++)
		ave += arr[i];
	ave /= size;
	return ave;
}
[11/09/22, 16:50:16] â€ª+52Â 444Â 285Â 9212â€¬: No imagine que fuera por el buffer jjejeje
[11/09/22, 16:54:34] Alfredo VillaseÃ±or: @5214443802885 
Por alguna razÃ³n termina la ejecuciÃ³n antes de la instrucciÃ³n
auxiliary = scan_family_ages(family_members);
del main:(

/ LibrerÃ­as
#include <stdio.h>

// Prototipos
int scan_family_members();
int scan_family_ages(int members_number);
void calculate_average_age(int members_number, int *aux);

/// FUNCIÃ“N PRINCIPAL
int main(){
    int family_members, auxiliary;

    family_members = scan_family_members();
    auxiliary = scan_family_ages(family_members);
    calculate_average_age(family_members, &auxiliary);
}

// FunciÃ³n para pedir el nÃºmero de integrantes
int scan_family_members(){
    int members_number;

    printf("No. de integrantes en la familia: ");
    scanf("%d", members_number);

    return(members_number);
}

// FunciÃ³n para pedir las edades de los integrantes
int scan_family_ages(int members_number){
    int i, age, aux = 0;

    for(i = 1; i <= members_number; i++){
        printf("\n------ EDAD INTEGRANTE %d ------\n", i);
        printf("Anios: ");
        scanf("%d", &age);
        aux += age * 12;
        printf("Meses: ");
        scanf("%d", &age);
        aux += age;
    }

    return(aux);
}

// FunciÃ³n para capturar y mostrar la edad promedio
void calculate_average_age(int members_number, int *aux){
    int years, months;

    *aux /= members_number;
    years = *aux / 12;
    months = *aux % 12;

    printf("\n------ EDAD PROMEDIO ------\n");
    printf("Anios: %d", years);
    printf("Meses: %d", months);
}
[11/09/22, 16:57:48] â€ª+52Â 444Â 380Â 2885â€¬: ah caray, yo ya andaba haciendo uno, pero llevaba poco

DÃ©jame checar eso que me dices
[11/09/22, 17:22:36] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036 avisas cuando puedas
[11/09/22, 17:22:53] Raul Moreno: Ya puedo, como quieres hacerlo?
[11/09/22, 17:27:05] â€ª+52Â 444Â 136Â 6505â€¬: Como vamos a regresar el resultado? por parametro o retorno?
[11/09/22, 17:28:23] Raul Moreno: Creo que no debemos regresar ningÃºn valor, o si @5214445027537 ?
[11/09/22, 17:40:15] â€ª+52Â 444Â 136Â 6505â€¬: //PROTOTIPO: 
//void dias();

//LIBRERÃAS:
//#include <stdio.h>
//#include <stdlib.h>

//FUNCION:

void dias()
{
    int dia, anio;
    
    printf("\nIngresa el dia de le fecha a consultar:");
    scanf("%i", &dia);
    
    printf("\nIngresa el anio de la fecha a consultar:");
    scanf("%i", &anio);
}
[11/09/22, 17:40:20] â€ª+52Â 444Â 136Â 6505â€¬: Esto es lo que llevo
[11/09/22, 17:41:19] Raul Moreno: Chin creo que llevamos mas o menos lo mismo jajaa
[11/09/22, 17:41:22] Raul Moreno: Deja te lo mando
[11/09/22, 17:41:53] â€ª+52Â 444Â 136Â 6505â€¬: Va
[11/09/22, 17:42:20] â€ª+52Â 444Â 136Â 6505â€¬: //PROTOTIPO: 
//void dias();

//LIBRERÃAS:
//#include <stdio.h>
//#include <stdlib.h>

//FUNCION:

void dias()
{
    int dia, mes, anio;
    
    printf("\nIngresa el dia de le fecha a consultar:");
    scanf("%i", &dia);
    
    printf("\nIngresa el mes de le fecha a consultar:");
    scanf("%i", &mes);
    
    printf("\nIngresa el anio de la fecha a consultar:");
    scanf("%i", &anio);
}
[11/09/22, 17:43:28] Raul Moreno: â€Se eliminÃ³ este mensaje.
[11/09/22, 17:43:45] Raul Moreno: //PROTOTIPO: 
//void dias();

//LIBRERÃAS:
//#include <stdio.h>
//#include <stdlib.h>

//FUNCION

void dias{
    int current_day,current_month, current_year;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current_day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current_month = local->tm_mon + 1; // obtener el mes del aÃ±o (0 a 11)
    current_year = local->tm_year + 1900; // obtener el aÃ±o desde 1900 
    
    int future_day, future_month, future_year,cont=1;
    while(cont){
        printf("\nIngrese el DIA: ");
        scanf("%d",&future_day);
        printf("\nIngrese el MES: ");
        scanf("%d",&future_month);
        printf("\nIngrese el ANIO: ");
        scanf("%d",&future_year);
        if(!((future_day<32&&future_day>0)&&(future_month<13&&future_month>0)&&(future_month>current_year)){
            printf("Ingrese una fecha valida \n");
        }else{
            cont=0;
        }
    }
}
[11/09/22, 17:44:17] Raul Moreno: Creo que lo Ãºnico diferente es que puse un ciclo para validar que la fecha ingresada sea correcta
[11/09/22, 17:44:33] â€ª+52Â 444Â 285Â 9212â€¬: Tenemos que preocuparnos por la memoria? ğŸ¤ 
[11/09/22, 17:49:41] Mikel Barajas: Por quÃ©?
[11/09/22, 17:53:58] â€ª+52Â 444Â 285Â 9212â€¬: Bueno ya termine mi parte. Cuando el usuario especifique que esta utilizando grados Celsius quize evitar que pudiera convertirlo de nuevo a grados Celsius porque serÃ­a redundante, entonces hice la pregunta de a quÃ© escala quiere convertirlo dentro de cada case. Entonces le agreguÃ© como 4 lÃ­neas mÃ¡s a cada case,

Se lo puedo quitar y dejar todo de forma general, aunque tambiÃ©n  tendrÃ­a que agregar la opciÃ³n si el usuario quisiera por alguna extraÃ±a razÃ³n convertirlo a la misma escala jjajaja
[11/09/22, 17:54:03] â€ª+52Â 444Â 285Â 9212â€¬: Si no ya para asÃ­ dejarlo
[11/09/22, 18:05:45] â€ª+52Â 444Â 136Â 6505â€¬: Podemos usar estructuras?
[11/09/22, 18:17:55] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036 para obtener la fecha actual no necesitas la libreria time.h?
[11/09/22, 18:23:39] Raul Moreno: Cierto, se me paso ponerla
[11/09/22, 18:33:23] â€ª+52Â 444Â 136Â 6505â€¬: #include <stdio.h>
#include <stdlib.h>
#include <time.h>>

typedef struct {
        int dia;
        int mes;
        int anio;
} TFecha;

int DiasTranscurridos(TFecha Fecha);

int main()
{
    TFecha fecha1, fecha2;
    int anioinicio=0, aniofinal=0, numanios=0, sumadias;
    long totaldias=0;

    time_t now;

    time(&now);

    struct tm *local = localtime(&now);

    fecha2.dia = local->tm_mday;
    fecha2.mes = local->tm_mon + 1;
    fecha2.anio = local->tm_year + 1900;

    printf("\nIngresa el dia de la fecha a consultar:");
    scanf("%i", &fecha1.dia);

    printf("\nIngresa el mes de la fecha a consultar:");
    scanf("%i", &fecha1.mes);

    printf("\nIngresa el anio de la fecha a consultar:");
    scanf("%i", &fecha1.anio);


    printf("\n\n%i %i %i", fecha1.dia, fecha1.mes, fecha1.anio);

    printf("\n\n%i %i %i", fecha2.dia, fecha2.mes, fecha2.anio);


    anioinicio = fecha1.anio==fecha2.anio?0:
          365 - DiasTranscurridos(fecha1);

    aniofinal = DiasTranscurridos(fecha2);


    for(numanios=fecha1.anio+1;numanios<fecha2.anio;numanios)
     {
        sumadias+=365;
     }

     totaldias+=anioinicio+aniofinal;

     printf("\n\n\n %i", totaldias);
}


int DiasTranscurridos(TFecha Fecha)
{
  int contador=0, suma=0, dia=Fecha.dia, mes=Fecha.mes, anio=Fecha.anio;

  int Meses[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (contador=0;contador<mes-1;contador++)
  {
     suma+= Meses[contador];
  }

  suma+= dia;

  if(((anio%4==0) && (anio%100!=0)) || (anio%400==0) && mes>2)
     suma++;
  return suma;
}
[11/09/22, 18:33:51] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036 creo que ya quedo, pero no le puse lo de verificar si la fecha es valida
[11/09/22, 18:34:32] Raul Moreno: Oye eso era lo que te iba comentar, el aÃ±o lo estas tomando como 365? Es que yo lo pensaba calcular tambiÃ©n con los bisiestos pero no se
[11/09/22, 18:45:28] â€ª+52Â 444Â 136Â 6505â€¬: Deja le agrego eso
[11/09/22, 18:52:16] â€ª+52Â 444Â 380Â 2885â€¬: *PROBLEMA D) EDADES*

@5214442145259 

Ya hice un cÃ³digo nuevo, solo que todo lo hice en el main, mira te lo paso y lo checas
[11/09/22, 18:52:38] â€ª+52Â 444Â 380Â 2885â€¬: #include<stdio.h>
#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

typedef struct
{
    float age_month;
    int age_year;
}family;


int main()
{
    family arr_family[MAX];
    int members;
    int i;
    float month,total;
    int aux;
    int year_2;
    float month_2;

    printf("El numero de miembros en tu familia:  ");

    scanf("%d",&members);
    for(i = 0; i < members; i++)
    {
        printf("Edad en anios del integrante %d\n",i + 1);
        scanf("%d",&arr_family[i].age_year);
        printf("Edad en mes del integrante %d\n",i + 1);
        scanf("%f",&month);

        month = month * CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        arr_family[i].age_month = month;
        total = total + arr_family[i].age_year + month;
    }
    total = total / members;

    year_2 = total;
    month_2 = total - year_2;
    month_2 = month_2 * 10;

    printf("El promedio de edad es %d anios y %.0f meses ",year_2, month_2);
[11/09/22, 18:52:49] â€ª+52Â 444Â 136Â 6505â€¬: #include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
        int dia;
        int mes;
        int anio;
} TFecha;

int DiasTranscurridos(TFecha Fecha);

int main()
{
    TFecha fecha1, fecha2;
    int anioinicio=0, aniofinal=0, numanios=0;
    long totaldias=0;

    time_t now;

    time(&now);

    struct tm *local = localtime(&now);

    fecha1.dia = local->tm_mday;
    fecha1.mes = local->tm_mon + 1;
    fecha1.anio = local->tm_year + 1900;

    printf("\nIngresa el dia de la fecha a consultar:");
    scanf("%i", &fecha2.dia);

    printf("\nIngresa el mes de la fecha a consultar:");
    scanf("%i", &fecha2.mes);

    printf("\nIngresa el anio de la fecha a consultar:");
    scanf("%i", &fecha2.anio);


    printf("\n\n%i %i %i", fecha1.dia, fecha1.mes, fecha1.anio);

    printf("\n\n%i %i %i", fecha2.dia, fecha2.mes, fecha2.anio);


    anioinicio = fecha1.anio==fecha2.anio?0:
        365 - DiasTranscurridos(fecha1);


    aniofinal = DiasTranscurridos(fecha2);


    for(numanios=fecha1.anio+1;numanios<fecha2.anio;numanios)
     {
        if(((numanios%4==0) && (numanios%100!=0)))
            totaldias+=366;
        else
            totaldias+=365;
     }

     totaldias+=anioinicio+aniofinal;

     printf("\n\n\n El numero de dias transcurridos entre %i/%i/%i y  %i/%i/%i es: %i dias", fecha1.dia, fecha1.mes, fecha1.anio, fecha2.dia, fecha2.mes, fecha2.anio, totaldias);
}


int DiasTranscurridos(TFecha Fecha)
{
  int contador=0, suma=0, dia=Fecha.dia, mes=Fecha.mes, anio=Fecha.anio;

  int Meses[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (contador=0;contador<mes-1;contador++)
  {
     suma+= Meses[contador];
  }

  suma+= dia;

  if(((anio%4==0) && (anio%100!=0)) || (anio%400==0) && mes>2)
     suma++;
  return suma;
}
[11/09/22, 18:52:56] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036
[11/09/22, 19:04:06] â€ª+52Â 444Â 136Â 6505â€¬: @5214441190036 puedes agregarle la validacion de fecha?
[11/09/22, 19:04:39] Raul Moreno: Sip, tambiÃ©n ahorita le pongo los nombres de las variables como las pidiÃ³ Mikel
[11/09/22, 19:41:25] Raul Moreno: *PROBLEMA B* 
//PROTOTIPOS 
int Days_elapsed(date_t date);
void Days();

//LIBRERIAS 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//FUNCIONES 
void Days(){
    int start_year=0, end_year=0, num_years=0;
    long total_days=0;

    date_t current,future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1; // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900; // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\nIngresa el dia de la fecha a consultar:");
        scanf("%i", &future.day);

        printf("\nIngresa el mes de la fecha a consultar:");
        scanf("%i", &future.month);

        printf("\nIngresa el anio de la fecha a consultar:");
        scanf("%i", &future.year);
        if(!((future.day<32&&future.day>0)&&(future.month<13&&future.month>0)&&(future.year>current.year))){
            printf("Ingrese una fecha valida \n");
        }
        else{
            band=0;
        }
    }

    printf("\n%i/%i/%i", current.day, current.month, current.year);
    printf("\n%i/%i/%i", future.day, future.month, future.year);

    start_year = current.day==future.day?0:
        365 - Days_elapsed(current);

    end_year = Days_elapsed(future);

    for(num_years=current.day+1;num_years<future.day;num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days+=start_year+end_year;

     printf("\n\n El numero de dias transcurridos entre %i/%i/%i y  %i/%i/%i es: %i dias", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int Days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++)
  {
     sum+= months[cont];
  }

  sum+= date.day;

  if(((date.year%4==0) && (date.year%100!=0)) || (date.year%400==0) && date.month>2)
     sum++;
  return sum;
}
[11/09/22, 19:45:02] Alfredo VillaseÃ±or: @5214443802885 

EstÃ¡ bien, sÃ³lo faltÃ³ convertir a meses la parte fraccionaria del promedio

month_2 = month_2 * 12 / 10;

Esa instrucciÃ³n antes del printf del promedio y ya
[11/09/22, 19:52:24] Alfredo VillaseÃ±or: *PROBLEMA D*

@5214443802885 
Creo que quedarÃ­a asÃ­

// LIBRERÃAS
//#include <stdio.h>

// CONSTANTES
#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

typedef struct
{
    int age_year;
    float age_month;
} FAMILY;

// PROTOTIPO
void average_age();


// FUNCIÃ“N
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, aux, year_2;
    float month, month_2, total;

    printf("\nNumero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\nEdad en anios del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf("Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\nEl promedio de edad es %d anios y %.0f meses.\n", year_2, month_2);
}
[11/09/22, 19:57:54] â€ª+52Â 444Â 380Â 2885â€¬: Â¿Por que?
No te entendÃ­
[11/09/22, 20:02:57] Alfredo VillaseÃ±or: Supongamos que el promedio de edad es 17.5

El programa muestra
"El promedio de edad es 17 aÃ±os y *5* meses."

Cuando en realidad debe mostrar
"El promedio de edad es 17 aÃ±os y *6* meses."
Porque 0.5 aÃ±os son 6 meses.
[11/09/22, 20:04:54] â€ª+52Â 444Â 380Â 2885â€¬: ohh vale si ya te entendÃ­
[11/09/22, 20:05:06] â€ª+52Â 444Â 380Â 2885â€¬: entonces asÃ­ quedarÃ­a ya de final
[11/09/22, 20:07:16] â€ª+52Â 444Â 718Â 5474â€¬: Si lo resolviste?
[11/09/22, 20:07:43] â€ª+52Â 444Â 285Â 9212â€¬: Ahh si, se me olvido mandar mi funciÃ³n jjajaja
[11/09/22, 20:08:04] â€ª+52Â 444Â 718Â 5474â€¬: Ah porque puedes usar tambiÃ©n el gets para cadenas de caracteres
[11/09/22, 20:08:04] â€ª+52Â 444Â 887Â 5251â€¬: â€Se eliminÃ³ este mensaje.
[11/09/22, 20:08:19] â€ª+52Â 444Â 887Â 5251â€¬: El g)
[11/09/22, 20:08:41] â€ª+52Â 444Â 887Â 5251â€¬: Esperen tengo que corregirle
[11/09/22, 20:08:53] â€ª+52Â 444Â 285Â 9212â€¬: *PROBLEMA C*

//LIBRERIAS//
#include <stdlib.h>
#include <stdio.h>
//PROTOTIPO//
void get_temperature();



//FUNCION PARA CAMBIAR LA TEMPERATURA//
void get_temperature(){
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf("Ingresa la escala que estas utilizando[C/F/K]:");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf("Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(scale,temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [F/K]:");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf("%.2f Celsius a fahrenheits son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf("%.2f Celsius a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/K]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf("%.2f fahrenheits a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf("%.2f fahrenheits a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/F]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf("%.2f kelvin a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f kelvin a fahrenheits son: %.2f",temperature,converted_temperature);
            }
        break;
    }
}
[11/09/22, 20:12:41] â€ª+52Â 444Â 887Â 5251â€¬: void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
}
[11/09/22, 20:12:46] â€ª+52Â 444Â 887Â 5251â€¬: Problema g)
[11/09/22, 20:46:39] Mikel Barajas: Sin regresar nada
[11/09/22, 20:46:42] Mikel Barajas: Todo se imprime ahÃ­
[11/09/22, 20:46:50] Mikel Barajas: PerdÃ³n por responder hasta ahorita jajaja no lo leÃ­
â€[11/09/22, 20:46:52] Mikel Barajas: â€sticker omitido
[11/09/22, 20:47:01] Raul Moreno: Igual si lo hicimos asÃ­ jajaja
â€[11/09/22, 20:47:03] Raul Moreno: â€sticker omitido
[11/09/22, 20:47:05] Mikel Barajas: Puedes regresar valores en funciones auxiliares
[11/09/22, 20:47:13] Mikel Barajas: Pero en el â€œmÃ³duloâ€ no
[11/09/22, 20:47:15] Mikel Barajas: Con todo
[11/09/22, 21:38:34] Mikel Barajas: â€Eliminaste este mensaje.
[11/09/22, 21:39:25] Mikel Barajas: *Problema G*

//LIBRERIAS//
#include <stdio.h>
#include <stdlib.h>

//CONSTANTES//
#define MAX 1000

//PROTOTIPOS//
void g_estadistica();

void scan_sample(double *sample, int size);
int double_comparator(const void* a, const void* b);

double get_arithmetic_mean(double *sample, int size);
double get_mode(double *sample, int size);
double get_median(double *sample, int size);

//FUNCIONES//

// Obtener las mÃ¡s simples medidas estadÃ­sticas relacionadas con una poblaciÃ³n dada a partir de los datos de una muestra de esa poblaciÃ³n.
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\nIngresar tamaÃ±o de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\nTamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{

        printf("\n\nOperaciÃ³n a realizar: " );
        printf("\n> 1. Media aritmÃ©tica." );
        printf("\n> 2. Moda." );
        printf("\n> 3. Mediana." );
        printf("\n> 4. Salir." );
        printf("\n");

        scanf("%d", &op);
        
        switch(op)
        {
            case 1:
                printf("\nMedia aritmÃ©tica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\nModa: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\nMediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\nSaliendo..."); 
                break;
            
            default:
                printf("\nOpciÃ³n invÃ¡lida."); 
                break;
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size){
    for(int i = 0; i < size; i++){
        printf("Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return **(double **)a - **(double **)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size){

	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size){

    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size){
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}
[11/09/22, 21:39:53] Mikel Barajas: PerdÃ³n, enviÃ© el mensaje recortado
[12/09/22, 11:06:12] â€ª+52Â 444Â 718Â 5474â€¬: Banda, un favorsote, vuelvan a mandar sus funciones PERO solo la funciÃ³n, nada de prototipos ni de librerÃ­as A MENOS que las librerÃ­as sean diferentes de la stdio y la stdlib, por ejemplo si usan otras esas si pÃ³ngalas, tambiÃ©n al principio del mensaje pÃ³nganle PROBLEMA A) por ejemplo, para ya tener las funciones definitivas y acomodarlas en el main
[12/09/22, 11:06:26] â€ª+52Â 444Â 718Â 5474â€¬: Recuerden que todas deben ser void y sin paso de parÃ¡metros
[12/09/22, 11:06:42] â€ª+52Â 444Â 718Â 5474â€¬: Si usan funciones adicionales tambiÃ©n pÃ³nganlas por favor
[12/09/22, 11:19:14] Raul Moreno: *PROBLEMA B)* 
//LIBRERIAS 
#include <time.h>

//FUNCIONES 
void Days(){
    int start_year=0, end_year=0, num_years=0;
    long total_days=0;

    date_t current,future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1; // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900; // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\nIngresa el dia de la fecha a consultar:");
        scanf("%i", &future.day);

        printf("\nIngresa el mes de la fecha a consultar:");
        scanf("%i", &future.month);

        printf("\nIngresa el anio de la fecha a consultar:");
        scanf("%i", &future.year);
        if(!((future.day<32&&future.day>0)&&(future.month<13&&future.month>0)&&(future.year>current.year))){
            printf("Ingrese una fecha valida \n");
        }
        else{
            band=0;
        }
    }

    printf("\n%i/%i/%i", current.day, current.month, current.year);
    printf("\n%i/%i/%i", future.day, future.month, future.year);

    start_year = current.day==future.day?0:
        365 - Days_elapsed(current);

    end_year = Days_elapsed(future);

    for(num_years=current.day+1;num_years<future.day;num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days+=start_year+end_year;

     printf("\n\n El numero de dias transcurridos entre %i/%i/%i y  %i/%i/%i es: %i dias", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int Days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++)
  {
     sum+= months[cont];
  }

  sum+= date.day;

  if(((date.year%4==0) && (date.year%100!=0)) || (date.year%400==0) && date.month>2)
     sum++;
  return sum;
}
[12/09/22, 12:18:39] Montserrat Gallegos: â€Se eliminÃ³ este mensaje.
[12/09/22, 12:18:57] Montserrat Gallegos: // *PROBLEMA A*

void is_a_leap_year(){
    int year, leap_year;

    do{
        printf("Ingresa el anio a consultar:\n");
        scanf("%d", &year);
        if(year<0){
            printf("El anio no es valido:\n");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf("El anio SI es bisiesto\n");
    }else{
        printf("El anio NO es bisiesto\n");
    }
}
[12/09/22, 15:24:06] â€ª+52Â 444Â 285Â 9212â€¬: *PROBLEMA C*

//FUNCION PARA CAMBIAR LA TEMPERATURA//
void get_temperature(){
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf("Ingresa la escala que estas utilizando[C/F/K]:");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf("Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(scale,temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [F/K]:");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf("%.2f Celsius a fahrenheits son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf("%.2f Celsius a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/K]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf("%.2f fahrenheits a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf("%.2f fahrenheits a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/F]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf("%.2f kelvin a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f kelvin a fahrenheits son: %.2f",temperature,converted_temperature);
            }
        break;
    }
}
[12/09/22, 17:36:15] â€ª+52Â 444Â 374Â 1420â€¬: *PROBLEMA E*
//Libreria
#include <math.h>

//Funcion
void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    char resp;
    do
    {
        printf("Ingresa el angulo en radianes: ");
        scanf("%f",&radianes);
        printf("Elige la funcion a realizar:\n");
        printf("1. Seno\n");
        printf("2. Coseno\n");
        printf("3. Tangente\n");
        scanf("%d",&funcion_del_angulo);
        switch(funcion_del_angulo)
        {
            case 1:     //Funcion seno
                resultado=sin(radianes);
                printf("Seno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 2:     //Funcion coseno
                resultado=cos(radianes);
                printf("Coseno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 3:     //Funcion tangente
                resultado=tan(radianes);
                printf("Tangente de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            default:
                printf("Esa opcion no esta disponible, vuelva a intentar\n");
        }
        printf("Continuar(s/n)");
        scanf(" %c",&resp);
    }while(resp=='s');
}
[12/09/22, 17:38:00] Mikel Barajas: *Problema G*

//FUNCIONES//

// Obtener las mÃ¡s simples medidas estadÃ­sticas relacionadas con una poblaciÃ³n dada a partir de los datos de una muestra de esa poblaciÃ³n.
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\nIngresar tamaÃ±o de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\nTamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{

        printf("\n\nOperaciÃ³n a realizar: " );
        printf("\n> 1. Media aritmÃ©tica." );
        printf("\n> 2. Moda." );
        printf("\n> 3. Mediana." );
        printf("\n> 4. Salir." );
        printf("\n");

        scanf("%d", &op);
        
        switch(op)
        {
            case 1:
                printf("\nMedia aritmÃ©tica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\nModa: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\nMediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\nSaliendo..."); 
                break;
            
            default:
                printf("\nOpciÃ³n invÃ¡lida."); 
                break;
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size){
    for(int i = 0; i < size; i++){
        printf("Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return **(double **)a - **(double **)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size){

	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size){

    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size){
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}
[12/09/22, 18:07:37] â€ª+52Â 444Â 380Â 2885â€¬: *PROBLEMA D*

// CONSTANTES
#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

typedef struct
{
    int age_year;
    float age_month;
} FAMILY;

// PROTOTIPO
void average_age();


// FUNCIÃ“N
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, aux, year_2;
    float month, month_2, total;

    printf("\nNumero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\nEdad en anios del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf("Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\nEl promedio de edad es %d anios y %.0f meses.\n", year_2, month_2);
}
[12/09/22, 19:39:47] Mikel Barajas: QuiÃ©n falta de mandar su parte asÃ­?
[12/09/22, 19:40:16] Mikel Barajas: @5214441932391 @5214442145259 @5214443163254 @5214871594881 @5214441190036 @5214441366505 @5214442859212 @5214443741420 @5214443802885 @5214447185474 @5214448875251
[12/09/22, 20:04:58] â€ª+52Â 444Â 718Â 5474â€¬: Bro este serÃ­a el F no?
[12/09/22, 20:05:09] â€ª+52Â 444Â 718Â 5474â€¬: Nomas pa cambiarle acÃ¡ en donde lo estoy haciendo xdd
[12/09/22, 20:05:40] Mikel Barajas: SÃ­
[12/09/22, 20:05:42] Mikel Barajas: PerdÃ³n
[12/09/22, 20:05:45] â€ª+52Â 444Â 718Â 5474â€¬: Ok, gracias
[12/09/22, 20:05:51] â€ª+52Â 444Â 718Â 5474â€¬: No hay problema ;D
[12/09/22, 20:05:55] Mikel Barajas: Se me fue la onda jaja
[12/09/22, 20:13:08] â€ª+52Â 444Â 285Â 9212â€¬: Yo ya mande la mia
[12/09/22, 20:15:14] â€ª+52Â 444Â 380Â 2885â€¬: Yo y mi equipo ya la mandamos
[12/09/22, 20:15:59] Montserrat Gallegos: Yo tmb mandÃ© la mÃ­a
[12/09/22, 20:19:39] â€ª+52Â 444Â 887Â 5251â€¬: *Problema G*

void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
}
[12/09/22, 20:28:40] â€ª+52Â 444Â 718Â 5474â€¬: #include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

typedef struct{
    int age_year;
    float age_month;
}FAMILY;

int main()
{
	int opcion;

	do
    {
    	printf("\n |------------------PROGRAMA FORMULAS 2022------------------|");
		printf("\n |1. BISIESTO                         5. TRIGONOMETRIA      |");
		printf("\n |2. DIAS PARA LLEGAR A UNA FECHA     6. ESTADISTICA        |");
		printf("\n |3. TEMPERATURA                      7. FACTORIAL	      |");
		printf("\n |4. EDADES                           8. SALIR              |");
		printf("\n |----------------------------------------------------------|");
		printf("\n\n Elige una opcion: ");
		scanf("%d",&opcion);

    	switch(opcion)
    	{
    		case 1:
    			printf("\n BISIESTO");
    			//PROBLEMA A
				void is_a_leap_year();
    			break;
    		case 2:
    			printf("\n DIAS PARA LLEGAR A UNA FECHA");
    			//PROBLEMA B
				void Days();
    			break;
    		case 3:
    			printf("\n TEMPERATURA");
    			//PROBLEMA C
				void get_temperature();
    			break;
    		case 4:
    			printf("\n EDADES");
    			//PROBLEMA D
				void average_age();
    			break;
    		case 5:
    			printf("\n TRIGONOMETRIA");
    			//PROBLEMA E
				void Trigonometria();
    			break;
    		case 6:
    			printf("\n ESTADISTICA");
    			//PROBLEMA F
				void g_estadistica();		
    			break;
    		case 7:
    			printf("\n FACTORAIL");
				//PROBLEMA G
				void factorial();
    			break;
    		case 8:
    			break;
    		default:
    			printf("\n NO EXISTE");
		}
	}while(opcion != 8);
    
    return 0;
}

///////////////////////////////////////////////////PROBLEMA A////////////////////////////////////////////////
void is_a_leap_year(){
    int year, leap_year;

    do{
        printf("Ingresa el anio a consultar:\n");
        scanf("%d", &year);
        if(year<0){
            printf("El anio no es valido:\n");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf("El anio SI es bisiesto\n");
    }else{
        printf("El anio NO es bisiesto\n");
    }
}

///////////////////////////////////////////////////PROBLEMA B////////////////////////////////////////////////

int Days_elapsed(date_t date);

void Days(){
    int start_year=0, end_year=0, num_years=0;
    long total_days=0;

    date_t current,future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1; // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900; // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\nIngresa el dia de la fecha a consultar:");
        scanf("%i", &future.day);

        printf("\nIngresa el mes de la fecha a consultar:");
        scanf("%i", &future.month);

        printf("\nIngresa el anio de la fecha a consultar:");
        scanf("%i", &future.year);
        if(!((future.day<32&&future.day>0)&&(future.month<13&&future.month>0)&&(future.year>current.year))){
            printf("Ingrese una fecha valida \n");
        }
        else{
            band=0;
        }
    }

    printf("\n%i/%i/%i", current.day, current.month, current.year);
    printf("\n%i/%i/%i", future.day, future.month, future.year);

    start_year = current.day==future.day?0:
        365 - Days_elapsed(current);

    end_year = Days_elapsed(future);

    for(num_years=current.day+1;num_years<future.day;num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days+=start_year+end_year;

     printf("\n\n El numero de dias transcurridos entre %i/%i/%i y  %i/%i/%i es: %i dias", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int Days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++)
  {
     sum+= months[cont];
  }

  sum+= date.day;

  if(((date.year%4==0) && (date.year%100!=0)) || (date.year%400==0) && date.month>2)
     sum++;
  return sum;
}

///////////////////////////////////////////////////PROBLEMA C////////////////////////////////////////////////
void get_temperature(){
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf("Ingresa la escala que estas utilizando[C/F/K]:");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf("Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(scale,temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [F/K]:");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf("%.2f Celsius a fahrenheits son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf("%.2f Celsius a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/K]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf("%.2f fahrenheits a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf("%.2f fahrenheits a kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\nIngresa la escala a la que la quieres convertir: [C/F]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf("%.2f kelvin a celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f kelvin a fahrenheits son: %.2f",temperature,converted_temperature);
            }
        break;
    }
}

///////////////////////////////////////////////////PROBLEMA D////////////////////////////////////////////////
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, aux, year_2;
    float month, month_2, total;

    printf("\nNumero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\nEdad en anios del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf("Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\nEl promedio de edad es %d anios y %.0f meses.\n", year_2, month_2);
}


///////////////////////////////////////////////////PROBLEMA E////////////////////////////////////////////////
void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    char resp;
    do
    {
        printf("Ingresa el angulo en radianes: ");
        scanf("%f",&radianes);
        printf("Elige la funcion a realizar:\n");
        printf("1. Seno\n");
        printf("2. Coseno\n");
        printf("3. Tangente\n");
        scanf("%d",&funcion_del_angulo);
        switch(funcion_del_angulo)
        {
            case 1:     //Funcion seno
                resultado=sin(radianes);
                printf("Seno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 2:     //Funcion coseno
                resultado=cos(radianes);
                printf("Coseno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 3:     //Funcion tangente
                resultado=tan(radianes);
                printf("Tangente de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            default:
                printf("Esa opcion no esta disponible, vuelva a intentar\n");
        }
        printf("Continuar(s/n)");
        scanf(" %c",&resp);
    }while(resp=='s');
}

///////////////////////////////////////////////////PROBLEMA F////////////////////////////////////////////////

//Leer la muestra de datos
void scan_sample(double *sample, int size);
//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b);
//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size);
//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size);
//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size);

void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\nIngresar tamaÃ±o de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\nTamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{

        printf("\n\nOperaciÃ³n a realizar: " );
        printf("\n> 1. Media aritmÃ©tica." );
        printf("\n> 2. Moda." );
        printf("\n> 3. Mediana." );
        printf("\n> 4. Salir." );
        printf("\n");

        scanf("%d", &op);
        
        switch(op)
        {
            case 1:
                printf("\nMedia aritmÃ©tica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\nModa: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\nMediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\nSaliendo..."); 
                break;
            
            default:
                printf("\nOpciÃ³n invÃ¡lida."); 
                break;
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size){
    for(int i = 0; i < size; i++){
        printf("Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return *(double *)a - *(double *)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size){

	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size){

    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size){
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}

///////////////////////////////////////////////////PROBLEMA G////////////////////////////////////////////////
void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
	printf("El factorial de %d es %d",dato,factorial);
}
[12/09/22, 20:28:49] â€ª+52Â 444Â 718Â 5474â€¬: BÃ¡sicamente esto es el programa
[12/09/22, 20:28:58] â€ª+52Â 444Â 718Â 5474â€¬: Pero tira muchos errores con la funciÃ³n de Days
[12/09/22, 20:29:57] â€ª+52Â 444Â 718Â 5474â€¬: Los prototipos estÃ¡n declarados dentro de cada Case, y los que hicieron sus funciones de mÃ¡s los declare en la parte del problema de cada uno
[12/09/22, 20:30:04] â€ª+52Â 444Â 718Â 5474â€¬: No se que proceda con lo del Days
[12/09/22, 20:31:40] Raul Moreno: Creo que fue porque no pusiste el struct
[12/09/22, 20:31:48] â€ª+52Â 444Â 718Â 5474â€¬: Si estÃ¡
[12/09/22, 20:31:49] Raul Moreno: SegÃºn yo si lo mande con todo y struct
[12/09/22, 20:31:56] â€ª+52Â 444Â 718Â 5474â€¬: el de Family?
[12/09/22, 20:32:01] â€ª+52Â 444Â 718Â 5474â€¬: O falta otro struct?
[12/09/22, 20:32:44] â€ª+52Â 444Â 718Â 5474â€¬: Si, falta un struct man
[12/09/22, 20:32:48] Raul Moreno: Falta otro
[12/09/22, 20:32:50] Raul Moreno: El de los dÃ­as jajaa
[12/09/22, 20:32:51] â€ª+52Â 444Â 718Â 5474â€¬: Pero no estÃ¡
[12/09/22, 20:32:53] â€ª+52Â 444Â 718Â 5474â€¬: Mandamelo
[12/09/22, 20:32:54] Raul Moreno: Por eso te da error
[12/09/22, 20:32:54] Mikel Barajas: Los prototipos deben ir todos hasta arriba
[12/09/22, 20:32:55] â€ª+52Â 444Â 718Â 5474â€¬: Paro
[12/09/22, 20:32:58] Mikel Barajas: Al menos arriba del main
[12/09/22, 20:33:09] Mikel Barajas: Para que no mande errores
[12/09/22, 20:34:21] â€ª+52Â 444Â 718Â 5474â€¬: Smn, que no estÃ¡ declarado un tipo date_t
[12/09/22, 20:34:23] â€ª+52Â 444Â 718Â 5474â€¬: Mandalo paro
[12/09/22, 20:34:36] Raul Moreno: typedef struct{
    int day;
    int month;
    int year;
}date_t;
[12/09/22, 20:34:45] Raul Moreno: Es ese
[12/09/22, 20:35:36] â€ª+52Â 444Â 718Â 5474â€¬: Ok gracias
[12/09/22, 20:43:21] â€ª+52Â 444Â 718Â 5474â€¬: Que equipo somos? @5214445027537
[12/09/22, 21:08:41] â€ª+52Â 444Â 718Â 5474â€¬: #include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

typedef struct{
    int age_year;
    float age_month;
}FAMILY;

typedef struct{
    int day;
    int month;
    int year;
}date_t;

//PROBLEMA A
void is_a_leap_year();

//PROBLEMA B
void Days();
int Days_elapsed(date_t date);

//PROBLEMA C
void get_temperature();

//PROBLEMA D
void average_age();

//PROBLEMA E
void Trigonometria();

//PROBLEMA F
// Obtener las mÃ¡s simples medidas estadÃ­sticas relacionadas con una poblaciÃ³n dada a partir de los datos de una muestra de esa poblaciÃ³n.
void g_estadistica();
//Leer la muestra de datos
void scan_sample(double *sample, int size);
//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b);
//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size);
//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size);
//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size);

//PROBLEMA G
void factorial();

/////////////////////////FUNCION PRINCIPAL////////////////////////////////////////
int main()
{
	int opcion;

	do
    {
    	printf("\n |------------------PROGRAMA FORMULAS 2022------------------|");
		printf("\n |1. BISIESTO                         5. TRIGONOMETRIA      |"); //Como observamos, de primera instancia tenemos un menÃº
		printf("\n |2. DIAS PARA LLEGAR A UNA FECHA     6. ESTADISTICA        |"); //el cual se programÃ³ con ayuda de un ciclo do while y
		printf("\n |3. TEMPERATURA                      7. FACTORIAL	    |");   //un switch. Mostramos cada opeciÃ³n y en una variable
		printf("\n |4. EDADES                           8. SALIR              |"); //guardamos el numero de la opciÃ³n elegida para mandarlo
		printf("\n |----------------------------------------------------------|"); //al switch de manera que cuando dicha variable sea 8
		printf("\n\n Elige una opcion: ");                                         //el ciclo do while nos sacarÃ¡ del programa.
		scanf("%d",&opcion);

    	switch(opcion)
    	{
    		case 1:
    			printf("\n BISIESTO \n");
    			//PROBLEMA A
				is_a_leap_year();
    			break;
    		case 2:
    			printf("\n DIAS PARA LLEGAR A UNA FECHA \n"); //Observemos que en cada case pusimos una funciÃ³n dependiendo de la opciÃ³n que
    			//PROBLEMA B                                    le correspondÃ­a seguido de un break para volver al menÃº de opciones.
				Days();
    			break;
    		case 3:
    			printf("\n TEMPERATURA \n");
    			//PROBLEMA C
				get_temperature();
    			break;
    		case 4:
    			printf("\n EDADES \n");
    			//PROBLEMA D
				average_age();
    			break;
    		case 5:
    			printf("\n TRIGONOMETRIA \n");
    			//PROBLEMA E
				Trigonometria();
    			break;
    		case 6:
    			printf("\n ESTADISTICA \n");
    			//PROBLEMA F
				g_estadistica();		
    			break;
    		case 7:
    			printf("\n FACTORIAL \n");
				//PROBLEMA G
				factorial();
    			break;
    		case 8:
    			printf("\n PROGRAMA ELABORADO POR EL EQUIPO 1 \n");
    			break;
    		default:
    			printf("\n NO EXISTE");
		}
	}while(opcion != 8);
    
    return 0;
}

///////////////////////////////////////////////////PROBLEMA A////////////////////////////////////////////////
void is_a_leap_year(){
    int year, leap_year;

    do{
        printf(" Ingresa el anio a consultar: ");
        scanf("%d", &year);
        if(year<0){
            printf(" El anio no es valido: ");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf(" El anio SI es bisiesto\n");
    }else{
        printf(" El anio NO es bisiesto\n");
    }
}

///////////////////////////////////////////////////PROBLEMA B////////////////////////////////////////////////
void Days(){
    int start_year=0, end_year=0, num_years=0;
    long total_days=0;

    date_t current,future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1; // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900; // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf(" Ingresa el dia de la fecha a consultar: ");
        scanf("%i", &future.day);

        printf(" Ingresa el mes de la fecha a consultar: ");
        scanf("%i", &future.month);

        printf(" Ingresa el anio de la fecha a consultar:");
        scanf("%i", &future.year);
        if(!((future.day<32&&future.day>0)&&(future.month<13&&future.month>0)&&(future.year>current.year))){
            printf(" Ingrese una fecha valida \n");
        }
        else{
            band=0;
        }
    }

    printf("\n %i/%i/%i", current.day, current.month, current.year);
    printf("\n %i/%i/%i", future.day, future.month, future.year);

    start_year = current.day==future.day?0:
        365 - Days_elapsed(current);

    end_year = Days_elapsed(future);

    for(num_years=current.day+1;num_years<future.day;num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days+=start_year+end_year;

     printf("\n\n El numero de dias transcurridos entre %i/%i/%i y  %i/%i/%i es: %i dias \n", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int Days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++)
  {
     sum+= months[cont];
  }

  sum+= date.day;

  if(((date.year%4==0) && (date.year%100!=0)) || (date.year%400==0) && date.month>2)
     sum++;
  return sum;
}

///////////////////////////////////////////////////PROBLEMA C////////////////////////////////////////////////
void get_temperature(){
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf(" Ingresa la escala que estas utilizando[C/F/K]:");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf(" Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(char scale, float temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[F/K]:");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf(" %.2f Celsius a Fahrenheits son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf(" %.2f Celsius a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/K]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf(" %.2f Fahrenheits a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf(" %.2f Fahrenheits a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/F]:");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf(" %.2f Kelvin a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f Kelvin a Fahrenheits son: %.2f",temperature,converted_temperature);
            }
        break;
    }
    printf("\n");
}

///////////////////////////////////////////////////PROBLEMA D////////////////////////////////////////////////
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, aux, year_2;
    float month, month_2, total;

    printf(" Numero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\n Edad en anios del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf(" Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\n El promedio de edad es %d anios y %.0f meses.\n", year_2, month_2);
}


///////////////////////////////////////////////////PROBLEMA E////////////////////////////////////////////////
void Trigonometria()
{
    float radianes,resultado;
    int funcion_del_angulo;
    char resp;
    do
    {
        printf(" Ingresa el angulo en radianes: ");
        scanf("%f",&radianes);
        printf(" 1. Seno\n");
        printf(" 2. Coseno\n");
        printf(" 3. Tangente\n");
        printf(" Elige la funcion a realizar: ");
        scanf("%d",&funcion_del_angulo);
        printf("\n");
        switch(funcion_del_angulo)
        {
            case 1:     //Funcion seno
                resultado=sin(radianes);
                printf(" Seno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 2:     //Funcion coseno
                resultado=cos(radianes);
                printf(" Coseno de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            case 3:     //Funcion tangente
                resultado=tan(radianes);
                printf(" Tangente de %.2f radianes: %.2f \n",radianes,resultado);
            break;
            default:
                printf(" Esa opcion no esta disponible, vuelva a intentar\n");
        }
        printf("\n Continuar(s/n): ");
        scanf(" %c",&resp);
    }while(resp=='s');
}

///////////////////////////////////////////////////PROBLEMA F////////////////////////////////////////////////
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf(" Ingresar tamano de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\n TamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{
        printf("\n\n> 1. Media aritmetica." );
        printf("\n> 2. Moda." );
        printf("\n> 3. Mediana." );
        printf("\n> 4. Salir." );
        printf("\n\n Operacion a realizar: " );
		scanf("%d", &op);
        printf("\n");

        switch(op)
        {
            case 1:
                printf("\n Media aritmetica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\n Moda: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\n Mediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\n Saliendo..."); 
                break;
            
            default:
                printf("\n Opcion invÃ¡lida."); 
                break;
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size){
    for(int i = 0; i < size; i++){
        printf(" Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return *(double *)a - *(double *)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size){

	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size){

    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size){
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}

///////////////////////////////////////////////////PROBLEMA G////////////////////////////////////////////////
void factorial()
{
    int factorial=1;
    int contador, dato;

    printf(" Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
	printf(" El factorial de %d es %d\n",dato,factorial);
}
[12/09/22, 21:08:43] â€ª+52Â 444Â 718Â 5474â€¬: Listo
[12/09/22, 21:08:49] â€ª+52Â 444Â 718Â 5474â€¬: Todo funciona correctamente
[12/09/22, 21:09:18] â€ª+52Â 444Â 718Â 5474â€¬: BÃ¡sicamente y en tÃ©rminos generales... estÃ¡ terminado
[12/09/22, 21:09:27] Mikel Barajas: Gracias bro
[12/09/22, 21:09:37] Mikel Barajas: MaÃ±ana todos hay que probar las funciones para ver quÃ© no se pase nada
[12/09/22, 21:09:41] Mikel Barajas: Pero por mientras
[12/09/22, 21:09:46] Mikel Barajas: Gracias a todos equipo
[12/09/22, 21:10:15] â€ª+52Â 444Â 718Â 5474â€¬: SimÃ³n, igual ya probÃ© todo y parece ser que funciona correctamente pero por si las dudas pruebenlo ;D
[12/09/22, 21:12:56] Raul Moreno: No digas eso, suena a que te vas a dar de baja
[12/09/22, 21:13:03] Raul Moreno: Y el que se va a dar de baja aquÃ­ soy yo
[12/09/22, 21:13:26] â€ª+52Â 444Â 193Â 2391â€¬: Cuenta conmigo
[12/09/22, 21:13:39] â€ª+52Â 444Â 718Â 5474â€¬: GPI
[15/09/22, 15:07:02] Mikel Barajas: Hola equipo
[15/09/22, 15:07:16] Mikel Barajas: Yo subo los archivos, nomÃ¡s si alguien mÃ¡s puede hacer pruebas estarÃ­a Perfecto
[15/09/22, 15:07:33] Mikel Barajas: Digan sÃ­ compila en su mÃ¡quina
[15/09/22, 15:07:35] Mikel Barajas: Y asÃ­
[15/09/22, 16:05:00] Mikel Barajas: *Problema Fechas*

Disculpen, quÃ© hace esta parte del cÃ³digo?

for(num_years=current.day+1;num_years<future.day;num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }
[15/09/22, 16:05:14] Mikel Barajas: Es que me manda un warning por lo Ãºltimo del for
[15/09/22, 16:29:37] Raul Moreno: Chin, deberÃ­as preguntarle a @5214441366505, el lo hizo, yo lo cambiÃ© al formato
[15/09/22, 16:29:51] Raul Moreno: Pero igual lo corrÃ­ en mi computadora y si jalo al 100
[15/09/22, 16:32:14] â€ª+52Â 444Â 718Â 5474â€¬: Ah caray, a mi no me marcÃ³ nada de nada ._.
[15/09/22, 16:32:25] â€ª+52Â 444Â 718Â 5474â€¬: Igual a ver @5214441366505
[15/09/22, 16:32:25] â€ª+52Â 444Â 136Â 6505â€¬: Checa si es bisiesto el aÃ±o
[15/09/22, 16:34:11] Mikel Barajas: Pero por quÃ© en un for?
[15/09/22, 16:39:32] Mikel Barajas: Bueno aÃºn asÃ­, si lo corre en replit no le va a dar el warning
[15/09/22, 16:39:46] Mikel Barajas: Ya quedÃ³ el archivo,solo me falta el comentario de los nombres
[15/09/22, 16:39:59] Mikel Barajas: Le hice unos cambios para que quedara con las convenciones
[15/09/22, 16:40:04] Mikel Barajas: De variables en inglÃ©s y asÃ­
[15/09/22, 16:40:13] Mikel Barajas: AdemÃ¡s cambiÃ© el borde para que tuviera esquinas
[15/09/22, 16:40:19] Mikel Barajas: Dejen lo mando por aquÃ­ para que lo vean
[15/09/22, 17:16:36] Mikel Barajas: #include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>

#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

/////////////////////////ESTRUCTURAS DE DATOS///////////////////////////////

typedef struct{
    int age_year;
    float age_month;
}FAMILY;

typedef struct{
    int day;
    int month;
    int year;
}date_t;

/////////////////////////PROTOTIPOS////////////////////////////////////////

//PROBLEMA A
void is_a_leap_year();

//PROBLEMA B
void days();
int days_elapsed(date_t date);

//PROBLEMA C
void get_temperature();

//PROBLEMA D
void average_age();

//PROBLEMA E
void trigonometry();

//PROBLEMA F
void g_estadistica();
void scan_sample(double *sample, int size);
int double_comparator(const void* a, const void* b);
double get_arithmetic_mean(double *sample, int size);
double get_mode(double *sample, int size);
double get_median(double *sample, int size);

//PROBLEMA G
void factorial();

/////////////////////////FUNCIÃ“N PRINCIPAL////////////////////////////////////////
int main()
{
    printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    printf("\n â•‘       TAREA 2: REQUERIMIENTOS Y TRABAJO EN EQUIPO        â•‘");
    printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    printf("\n\n INTEGRANTES: ");
    printf("\n â€¢ Abarca CÃ¡rcamo Alan Yahir ");
    printf("\n â€¢ Barajas MartÃ­nez Mikel Ignacio ");
    printf("\n â€¢ Cerda Moreno Carlos Raul ");
    printf("\n â€¢ HernÃ¡ndez Gallegos Montserrat Ximena ");
    printf("\n â€¢ HernÃ¡ndez Guerrero Sergio AndrÃ©s ");
    printf("\n â€¢ HernÃ¡ndez Salazar Isaih Roberto");
    printf("\n â€¢ Marquez Guerrero Kevin ");
    printf("\n â€¢ Ojeda GutiÃ©rrez Fernando Juriel");
    printf("\n â€¢ Rodriguez Perez JosÃ© Rogelio");
    printf("\n â€¢ Rojas MartÃ­nez Jorge Ãngel");
    printf("\n â€¢ Salazar Rico Diego IsaÃ­");
    printf("\n â€¢ VillaseÃ±or MonsivÃ¡is Alfredo ");
    printf("\n\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

	int op;
	do{
        fflush(stdin);
    	printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
		printf("\n â•‘1. BISIESTO                         5. TRIGONOMETRÃA      â•‘"); //Como observamos, de primera instancia tenemos un menÃº
		printf("\n â•‘2. DÃAS PARA LLEGAR A UNA FECHA     6. ESTADÃSTICA        â•‘"); //el cual se programÃ³ con ayuda de un ciclo do while y
		printf("\n â•‘3. TEMPERATURA                      7. FACTORIAL	    â•‘");   //un switch. Mostramos cada opeciÃ³n y en una variable
		printf("\n â•‘4. EDADES                           8. SALIR              â•‘"); //guardamos el numero de la opciÃ³n elegida para mandarlo
		printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"); //al switch de manera que cuando dicha variable sea 8
		printf("\n\n Elige una opciÃ³n: ");                                         //el ciclo do while nos sacarÃ¡ del programa.
		scanf("%d",&op);

        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    	switch(op)
    	{
    		case 1:
    			printf("\n BISIESTO \n");
    			//PROBLEMA A
				is_a_leap_year();
    			break;
    		case 2:
    			printf("\n DÃAS PARA LLEGAR A UNA FECHA \n"); //Observemos que en cada case pusimos una funciÃ³n dependiendo de la opciÃ³n que
    			//PROBLEMA B                                    le correspondÃ­a seguido de un break para volver al menÃº de opciones.
				days();
    			break;
    		case 3:
    			printf("\n TEMPERATURA \n");
    			//PROBLEMA C
				get_temperature();
    			break;
    		case 4:
    			printf("\n EDADES \n");
    			//PROBLEMA D
				average_age();
    			break;
    		case 5:
    			printf("\n TRIGONOMETRÃA \n");
    			//PROBLEMA E
				trigonometry();
    			break;
    		case 6:
    			printf("\n ESTADÃSTICA \n");
    			//PROBLEMA F
				g_estadistica();		
    			break;
    		case 7:
    			printf("\n FACTORIAL \n");
				//PROBLEMA G
				factorial();
    			break;
    		case 8:
    			printf("\n PROGRAMA ELABORADO POR EL EQUIPO 1 \n");
    			break;
    		default:
    			printf("\n OPCIÃ“N INVÃLIDA");
		}
        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
	} while(op != 8);
    
    return 0;
}

///////////////////////////////////////////////////PROBLEMA A////////////////////////////////////////////////
void is_a_leap_year()
{
    int year, leap_year;

    do{
        printf("\n Ingresa el aÃ±o a consultar: ");
        scanf("%d", &year);
        if(year<0){
            printf(" El aÃ±o no es vÃ¡lido. ");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf(" El aÃ±o SÃ es bisiesto\n");
    }else{
        printf(" El aÃ±o NO es bisiesto\n");
    }
}

///////////////////////////////////////////////////PROBLEMA B////////////////////////////////////////////////
void days()
{
    int start_year = 0, end_year = 0, num_years = 0;
    long total_days = 0;

    date_t current, future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1;       // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900;    // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\n Ingresa el dÃ­a de la fecha a consultar: ");
        scanf("%d", &future.day);

        printf(" Ingresa el mes de la fecha a consultar: ");
        scanf("%d", &future.month);

        printf(" Ingresa el aÃ±o de la fecha a consultar: ");
        scanf("%d", &future.year);

        if((future.day > 32 || future.day < 0) || (future.month > 13 || future.month < 0) || (future.year < current.year)){
            printf(" Ingrese una fecha vÃ¡lida \n");
        }
        else{
            band=0;
        }
    }

    start_year = current.day == future.day ? 0 : 365 - days_elapsed(current);

    end_year = days_elapsed(future);

    for(num_years=current.day+1; num_years<future.day; num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days += start_year + end_year;

     printf("\n\n El numero de dÃ­as transcurridos entre %i/%i/%i y %i/%i/%i es: %li dÃ­as \n", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++){
     sum+= months[cont];
  }

  sum+= date.day;

  if((((date.year % 4 == 0) && (date.year % 100 != 0)) || (date.year % 400==0)) && date.month>2){
    sum++;
  }

  return sum;
}

///////////////////////////////////////////////////PROBLEMA C////////////////////////////////////////////////
void get_temperature()
{
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf("\n Ingresa la escala que estas utilizando[C/F/K]: ");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf(" Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(char scale, float temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[F/K]: ");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf(" %.2f Celsius a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf(" %.2f Celsius a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/K]: ");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf(" %.2f Fahrenheit a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf(" %.2f Fahrenheit a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/F]: ");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf(" %.2f Kelvin a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f Kelvin a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
        break;
    }
    printf("\n");
}

///////////////////////////////////////////////////PROBLEMA D////////////////////////////////////////////////
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, year_2;
    float month, month_2, total;

    printf("\n NÃºmero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\n Edad en aÃ±os del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf(" Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\n El promedio de edad es %d aÃ±os y %.0f meses.\n", year_2, month_2);
}

///////////////////////////////////////////////////PROBLEMA E////////////////////////////////////////////////
void trigonometry()
{
    float rad, ans;
    int function;
    char op;
    do
    {
        fflush(stdin);
        printf("\n Ãngulo en radianes: ");
        scanf("%f",&rad);
        printf("\n 1. Seno");
        printf("\n 2. Coseno");
        printf("\n 3. Tangente");
        printf("\n\n FunciÃ³n a realizar: ");
        scanf("%d",&function);
        printf("\n");
        switch(function)
        {
            case 1:     //Funcion seno
                ans=sin(rad);
                printf(" Seno de %.2f radianes: %.2f \n", rad, ans);
            break;
            case 2:     //Funcion coseno
                ans=cos(rad);
                printf(" Coseno de %.2f radianes: %.2f \n", rad , ans);
            break;
            case 3:     //Funcion tangente
                ans=tan(rad);
                printf(" Tangente de %.2f radianes: %.2f \n", rad , ans);
            break;
            default:
                printf(" OpciÃ³n invÃ¡lida.\n");
        }
        printf("\n Continuar[s/n]: ");
        scanf(" %c",&op);
    }while(op=='s');
}

///////////////////////////////////////////////////PROBLEMA F////////////////////////////////////////////////
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\n Ingresar tamano de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\n TamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{
        fflush(stdin);
        printf("\n 1. Media aritmetica." );
        printf("\n 2. Moda." );
        printf("\n 3. Mediana." );
        printf("\n 4. Salir." );
        printf("\n\n Operacion a realizar: " );
		scanf("%d", &op);
        printf("\n");

        switch(op)
        {
            case 1:
                printf("\n Media aritmetica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\n Moda: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\n Mediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\n Saliendo...\n"); 
                break;
            
            default:
                printf("\n Opcion invÃ¡lida."); 
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size)
{
    for(int i = 0; i < size; i++){
        printf(" Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return *(double *)a - *(double *)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size)
{
	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size)
{
    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size)
{
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}

///////////////////////////////////////////////////PROBLEMA G////////////////////////////////////////////////
void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
	printf(" El factorial de %d es %d\n",dato,factorial);
}
[15/09/22, 17:16:47] Mikel Barajas: Le agregue el nombre de los integrantes tambiÃ©n
[15/09/22, 17:16:51] Mikel Barajas: Bueno falta en comentario
[15/09/22, 17:16:53] Mikel Barajas: Voy
[15/09/22, 17:20:17] Mikel Barajas: /*
IngenierÃ­a de Software

TAREA 2: REQUERIMIENTOS Y TRABAJO EN EQUIPO

â€¢ Abarca CÃ¡rcamo Alan Yahir
â€¢ Barajas MartÃ­nez Mikel Ignacio
â€¢ Cerda Moreno Carlos Raul
â€¢ HernÃ¡ndez Gallegos Montserrat Ximena
â€¢ HernÃ¡ndez Guerrero Sergio AndrÃ©s
â€¢ HernÃ¡ndez Salazar Isaih Roberto
â€¢ Marquez Guerrero Kevin
â€¢ Ojeda GutiÃ©rrez Fernando Juriel
â€¢ Rodriguez Perez JosÃ© Rogelio
â€¢ Rojas MartÃ­nez Jorge Ãngel
â€¢ Salazar Rico Diego IsaÃ­
â€¢ VillaseÃ±or MonsivÃ¡is Alfredo

15/09/2022
*/

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>

#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

/////////////////////////ESTRUCTURAS DE DATOS///////////////////////////////

typedef struct{
    int age_year;
    float age_month;
}FAMILY;

typedef struct{
    int day;
    int month;
    int year;
}date_t;

/////////////////////////PROTOTIPOS////////////////////////////////////////

//PROBLEMA A
void is_a_leap_year();

//PROBLEMA B
void days();
int days_elapsed(date_t date);

//PROBLEMA C
void get_temperature();

//PROBLEMA D
void average_age();

//PROBLEMA E
void trigonometry();

//PROBLEMA F
void g_estadistica();
void scan_sample(double *sample, int size);
int double_comparator(const void* a, const void* b);
double get_arithmetic_mean(double *sample, int size);
double get_mode(double *sample, int size);
double get_median(double *sample, int size);

//PROBLEMA G
void factorial();

/////////////////////////FUNCIÃ“N PRINCIPAL////////////////////////////////////////
int main()
{
    printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    printf("\n â•‘       TAREA 2: REQUERIMIENTOS Y TRABAJO EN EQUIPO        â•‘");
    printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    printf("\n\n INTEGRANTES: ");
    printf("\n â€¢ Abarca CÃ¡rcamo Alan Yahir ");
    printf("\n â€¢ Barajas MartÃ­nez Mikel Ignacio ");
    printf("\n â€¢ Cerda Moreno Carlos Raul ");
    printf("\n â€¢ HernÃ¡ndez Gallegos Montserrat Ximena ");
    printf("\n â€¢ HernÃ¡ndez Guerrero Sergio AndrÃ©s ");
    printf("\n â€¢ HernÃ¡ndez Salazar Isaih Roberto");
    printf("\n â€¢ Marquez Guerrero Kevin ");
    printf("\n â€¢ Ojeda GutiÃ©rrez Fernando Juriel");
    printf("\n â€¢ Rodriguez Perez JosÃ© Rogelio");
    printf("\n â€¢ Rojas MartÃ­nez Jorge Ãngel");
    printf("\n â€¢ Salazar Rico Diego IsaÃ­");
    printf("\n â€¢ VillaseÃ±or MonsivÃ¡is Alfredo ");
    printf("\n\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

	int op;
	do{
        fflush(stdin);
    	printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
		printf("\n â•‘1. BISIESTO                         5. TRIGONOMETRÃA      â•‘"); //Como observamos, de primera instancia tenemos un menÃº
		printf("\n â•‘2. DÃAS PARA LLEGAR A UNA FECHA     6. ESTADÃSTICA        â•‘"); //el cual se programÃ³ con ayuda de un ciclo do while y
		printf("\n â•‘3. TEMPERATURA                      7. FACTORIAL	    â•‘");   //un switch. Mostramos cada opeciÃ³n y en una variable
		printf("\n â•‘4. EDADES                           8. SALIR              â•‘"); //guardamos el numero de la opciÃ³n elegida para mandarlo
		printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"); //al switch de manera que cuando dicha variable sea 8
		printf("\n\n Elige una opciÃ³n: ");                                         //el ciclo do while nos sacarÃ¡ del programa.
		scanf("%d",&op);

        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    	switch(op)
    	{
    		case 1:
    			printf("\n BISIESTO \n");
    			//PROBLEMA A
				is_a_leap_year();
    			break;
    		case 2:
    			printf("\n DÃAS PARA LLEGAR A UNA FECHA \n"); //Observemos que en cada case pusimos una funciÃ³n dependiendo de la opciÃ³n que
    			//PROBLEMA B                                    le correspondÃ­a seguido de un break para volver al menÃº de opciones.
				days();
    			break;
    		case 3:
    			printf("\n TEMPERATURA \n");
    			//PROBLEMA C
				get_temperature();
    			break;
    		case 4:
    			printf("\n EDADES \n");
    			//PROBLEMA D
				average_age();
    			break;
    		case 5:
    			printf("\n TRIGONOMETRÃA \n");
    			//PROBLEMA E
				trigonometry();
    			break;
    		case 6:
    			printf("\n ESTADÃSTICA \n");
    			//PROBLEMA F
				g_estadistica();		
    			break;
    		case 7:
    			printf("\n FACTORIAL \n");
				//PROBLEMA G
				factorial();
    			break;
    		case 8:
    			printf("\n PROGRAMA ELABORADO POR EL EQUIPO 1 \n");
    			break;
    		default:
    			printf("\n OPCIÃ“N INVÃLIDA");
		}
        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
	} while(op != 8);
    
    return 0;
}

///////////////////////////////////////////////////PROBLEMA A////////////////////////////////////////////////
void is_a_leap_year()
{
    int year, leap_year;

    do{
        printf("\n Ingresa el aÃ±o a consultar: ");
        scanf("%d", &year);
        if(year<0){
            printf(" El aÃ±o no es vÃ¡lido. ");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf(" El aÃ±o SÃ es bisiesto\n");
    }else{
        printf(" El aÃ±o NO es bisiesto\n");
    }
}

///////////////////////////////////////////////////PROBLEMA B////////////////////////////////////////////////
void days()
{
    int start_year = 0, end_year = 0, num_years = 0;
    long total_days = 0;

    date_t current, future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1;       // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900;    // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\n Ingresa el dÃ­a de la fecha a consultar: ");
        scanf("%d", &future.day);

        printf(" Ingresa el mes de la fecha a consultar: ");
        scanf("%d", &future.month);

        printf(" Ingresa el aÃ±o de la fecha a consultar: ");
        scanf("%d", &future.year);

        if((future.day > 32 || future.day < 0) || (future.month > 13 || future.month < 0) || (future.year < current.year)){
            printf(" Ingrese una fecha vÃ¡lida \n");
        }
        else{
            band=0;
        }
    }

    start_year = current.day == future.day ? 0 : 365 - days_elapsed(current);

    end_year = days_elapsed(future);

    for(num_years=current.day+1; num_years<future.day; num_years)
     {
        if(((num_years%4==0) && (num_years%100!=0)))
            total_days+=366;
        else
            total_days+=365;
     }

     total_days += start_year + end_year;

     printf("\n\n El numero de dÃ­as transcurridos entre %i/%i/%i y %i/%i/%i es: %li dÃ­as \n", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int days_elapsed(date_t date)
{
  int sum=0;

  int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

  for (int cont=0;cont<date.month-1;cont++){
     sum+= months[cont];
  }

  sum+= date.day;

  if((((date.year % 4 == 0) && (date.year % 100 != 0)) || (date.year % 400==0)) && date.month>2){
    sum++;
  }

  return sum;
}

///////////////////////////////////////////////////PROBLEMA C////////////////////////////////////////////////
void get_temperature()
{
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
    printf("\n Ingresa la escala que estas utilizando[C/F/K]: ");
    scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');
    //AQUI SE INGRESA LA TEMPERATURA//
    printf(" Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(char scale, float temperature);
    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[F/K]: ");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf(" %.2f Celsius a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf(" %.2f Celsius a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'F':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/K]: ");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf(" %.2f Fahrenheit a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf(" %.2f Fahrenheit a Kelvin son: %.2f",temperature,converted_temperature);
            }
        break;

        case 'K':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/F]: ");
                scanf(" %c",&option);
            }while(option!='C' && option!='F');
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf(" %.2f Kelvin a Celsius son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f Kelvin a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
        break;
    }
    printf("\n");
}

///////////////////////////////////////////////////PROBLEMA D////////////////////////////////////////////////
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, year_2;
    float month, month_2, total;

    printf("\n NÃºmero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++)
    {
        printf("\n Edad en aÃ±os del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf(" Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\n El promedio de edad es %d aÃ±os y %.0f meses.\n", year_2, month_2);
}

///////////////////////////////////////////////////PROBLEMA E////////////////////////////////////////////////
void trigonometry()
{
    float rad, ans;
    int function;
    char op;
    do
    {
        fflush(stdin);
        printf("\n Ãngulo en radianes: ");
        scanf("%f",&rad);
        printf("\n 1. Seno");
        printf("\n 2. Coseno");
        printf("\n 3. Tangente");
        printf("\n\n FunciÃ³n a realizar: ");
        scanf("%d",&function);
        printf("\n");
        switch(function)
        {
            case 1:     //Funcion seno
                ans=sin(rad);
                printf(" Seno de %.2f radianes: %.2f \n", rad, ans);
            break;
            case 2:     //Funcion coseno
                ans=cos(rad);
                printf(" Coseno de %.2f radianes: %.2f \n", rad , ans);
            break;
            case 3:     //Funcion tangente
                ans=tan(rad);
                printf(" Tangente de %.2f radianes: %.2f \n", rad , ans);
            break;
            default:
                printf(" OpciÃ³n invÃ¡lida.\n");
        }
        printf("\n Continuar[s/n]: ");
        scanf(" %c",&op);
    }while(op=='s');
}

///////////////////////////////////////////////////PROBLEMA F////////////////////////////////////////////////
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\n Ingresar tamano de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\n TamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{
        fflush(stdin);
        printf("\n 1. Media aritmetica." );
        printf("\n 2. Moda." );
        printf("\n 3. Mediana." );
        printf("\n 4. Salir." );
        printf("\n\n Operacion a realizar: " );
		scanf("%d", &op);
        printf("\n");

        switch(op)
        {
            case 1:
                printf("\n Media aritmetica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\n Moda: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\n Mediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\n Saliendo...\n"); 
                break;
            
            default:
                printf("\n Opcion invÃ¡lida."); 
        }

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size)
{
    for(int i = 0; i < size; i++){
        printf(" Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return *(double *)a - *(double *)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size)
{
	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size)
{
    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size)
{
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}

///////////////////////////////////////////////////PROBLEMA G////////////////////////////////////////////////
void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++)
         factorial = factorial*contador;
	printf(" El factorial de %d es %d\n",dato,factorial);
}
[15/09/22, 17:27:56] â€ª+52Â 444Â 718Â 5474â€¬: Man pero todos los acentos se imprimen con simbolos raros
[15/09/22, 17:28:02] â€ª+52Â 444Â 718Â 5474â€¬: Por eso se los quitÃ© :v
[15/09/22, 17:29:44] Mikel Barajas: En replit sÃ­ deja
[15/09/22, 17:29:46] Mikel Barajas: Prueben ahÃ­
[15/09/22, 17:29:58] Mikel Barajas: El profe va a usar replit para correrlos
[15/09/22, 17:30:07] Mikel Barajas: CÃ³mo el de la tarea extra 1
[15/09/22, 17:32:21] Mikel Barajas: Bueno, vamos a hacer una versiÃ³n sin acentos de nuevo
[15/09/22, 17:32:23] Mikel Barajas: Por si acaso
[15/09/22, 17:32:33] Mikel Barajas: Pero me imagino sÃ­ usarÃ¡ replit
[15/09/22, 17:32:51] Mikel Barajas: @5214447185474 , puedes hacerla?
[15/09/22, 17:32:58] Mikel Barajas: Sobre esta versiÃ³n
[15/09/22, 17:33:38] Mikel Barajas: /*
IngenierÃ­a de Software

TAREA 2: REQUERIMIENTOS Y TRABAJO EN EQUIPO

â€¢ Abarca CÃ¡rcamo Alan Yahir
â€¢ Barajas MartÃ­nez Mikel Ignacio
â€¢ Cerda Moreno Carlos Raul
â€¢ HernÃ¡ndez Gallegos Montserrat Ximena
â€¢ HernÃ¡ndez Guerrero Sergio AndrÃ©s
â€¢ HernÃ¡ndez Salazar Isaih Roberto
â€¢ Marquez Guerrero Kevin
â€¢ Ojeda GutiÃ©rrez Fernando Juriel
â€¢ Rodriguez Perez JosÃ© Rogelio
â€¢ Rojas MartÃ­nez Jorge Ãngel
â€¢ Salazar Rico Diego IsaÃ­
â€¢ VillaseÃ±or MonsivÃ¡is Alfredo

15/09/2022
*/

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>

#define MAX 100
#define CONSTANT 0.08333 // Es la divisiÃ³n de 1 mes entre 12 que serÃ­a para pasar un mes a aÃ±os

/////////////////////////ESTRUCTURAS DE DATOS///////////////////////////////

typedef struct{
    int age_year;
    float age_month;
}FAMILY;

typedef struct{
    int day;
    int month;
    int year;
}date_t;

/////////////////////////PROTOTIPOS////////////////////////////////////////

//PROBLEMA A
void is_a_leap_year();

//PROBLEMA B
void days();
int days_elapsed(date_t date);

//PROBLEMA C
void get_temperature();

//PROBLEMA D
void average_age();

//PROBLEMA E
void trigonometry();

//PROBLEMA F
void g_estadistica();
void scan_sample(double *sample, int size);
int double_comparator(const void* a, const void* b);
double get_arithmetic_mean(double *sample, int size);
double get_mode(double *sample, int size);
double get_median(double *sample, int size);

//PROBLEMA G
void factorial();

/////////////////////////FUNCIÃ“N PRINCIPAL////////////////////////////////////////
int main()
{
    printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    printf("\n â•‘       TAREA 2: REQUERIMIENTOS Y TRABAJO EN EQUIPO        â•‘");
    printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    printf("\n\n INTEGRANTES: ");
    printf("\n â€¢ Abarca CÃ¡rcamo Alan Yahir ");
    printf("\n â€¢ Barajas MartÃ­nez Mikel Ignacio ");
    printf("\n â€¢ Cerda Moreno Carlos Raul ");
    printf("\n â€¢ HernÃ¡ndez Gallegos Montserrat Ximena ");
    printf("\n â€¢ HernÃ¡ndez Guerrero Sergio AndrÃ©s ");
    printf("\n â€¢ HernÃ¡ndez Salazar Isaih Roberto");
    printf("\n â€¢ Marquez Guerrero Kevin ");
    printf("\n â€¢ Ojeda GutiÃ©rrez Fernando Juriel");
    printf("\n â€¢ Rodriguez Perez JosÃ© Rogelio");
    printf("\n â€¢ Rojas MartÃ­nez Jorge Ãngel");
    printf("\n â€¢ Salazar Rico Diego IsaÃ­");
    printf("\n â€¢ VillaseÃ±or MonsivÃ¡is Alfredo ");
    printf("\n\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

	int op;
	do{
        fflush(stdin);
    	printf("\n â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
		printf("\n â•‘1. BISIESTO                         5. TRIGONOMETRÃA      â•‘"); //Como observamos, de primera instancia tenemos un menÃº
		printf("\n â•‘2. DÃAS PARA LLEGAR A UNA FECHA     6. ESTADÃSTICA        â•‘"); //el cual se programÃ³ con ayuda de un ciclo do while y
		printf("\n â•‘3. TEMPERATURA                      7. FACTORIAL          â•‘");   //un switch. Mostramos cada opeciÃ³n y en una variable
		printf("\n â•‘4. EDADES                           8. SALIR              â•‘"); //guardamos el numero de la opciÃ³n elegida para mandarlo
		printf("\n â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"); //al switch de manera que cuando dicha variable sea 8
		printf("\n\n Elige una opciÃ³n: ");                                         //el ciclo do while nos sacarÃ¡ del programa.
		scanf("%d",&op);

        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    	switch(op)
    	{
    		case 1:
    			printf("\n BISIESTO \n");
    			//PROBLEMA A
				is_a_leap_year();
    			break;

    		case 2:
    			printf("\n DÃAS PARA LLEGAR A UNA FECHA \n"); //Observemos que en cada case pusimos una funciÃ³n dependiendo de la opciÃ³n que
    			//PROBLEMA B                                    le correspondÃ­a seguido de un break para volver al menÃº de opciones.
				days();
    			break;

    		case 3:
    			printf("\n TEMPERATURA \n");
    			//PROBLEMA C
				get_temperature();
    			break;

    		case 4:
    			printf("\n EDADES \n");
    			//PROBLEMA D
				average_age();
    			break;

    		case 5:
    			printf("\n TRIGONOMETRÃA \n");
    			//PROBLEMA E
				trigonometry();
    			break;

    		case 6:
    			printf("\n ESTADÃSTICA \n");
    			//PROBLEMA F
				g_estadistica();		
    			break;

    		case 7:
    			printf("\n FACTORIAL \n");
				//PROBLEMA G
				factorial();
    			break;

    		case 8:
    			printf("\n UASLP, 2022 \n");
    			break;

    		default:
    			printf("\n OPCIÃ“N INVÃLIDA");
		}
        printf("\n â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
	} while(op != 8);
    
    return 0;
}

///////////////////////////////////////////////////PROBLEMA A////////////////////////////////////////////////
void is_a_leap_year()
{
    int year, leap_year;

    do{
        printf("\n Ingresa el aÃ±o a consultar: ");
        scanf("%d", &year);
        if(year<0){
            printf(" El aÃ±o no es vÃ¡lido. ");
        }
    }while(year<0);

    if(year%4==0){
        if(year%100 == 0){
            if(year%400 == 0){
                leap_year=1;
            }else{
                leap_year=0;
            }
        }else{
            leap_year=1;
        }
    }else{
        leap_year=0;
    }

    if(leap_year==1){
        printf(" El aÃ±o SÃ es bisiesto\n");
    }else{
        printf(" El aÃ±o NO es bisiesto\n");
    }
}

///////////////////////////////////////////////////PROBLEMA B////////////////////////////////////////////////
void days()
{
    int start_year = 0, end_year = 0, num_years = 0;
    long total_days = 0;

    date_t current, future;
    time_t now;
    time(&now);
    struct tm *local = localtime(&now);

    current.day = local->tm_mday;            // obtener el dÃ­a del mes (1 a 31)
    current.month = local->tm_mon + 1;       // obtener el mes del aÃ±o (0 a 11)
    current.year = local->tm_year + 1900;    // obtener el aÃ±o desde 1900

    int band=1;
    while(band){
        printf("\n Ingresa el dÃ­a de la fecha a consultar: ");
        scanf("%d", &future.day);

        printf(" Ingresa el mes de la fecha a consultar: ");
        scanf("%d", &future.month);

        printf(" Ingresa el aÃ±o de la fecha a consultar: ");
        scanf("%d", &future.year);

        if((future.day > 32 || future.day < 0) || (future.month > 13 || future.month < 0) || (future.year < current.year)){
            printf(" Ingrese una fecha vÃ¡lida \n");
        }
        else{
            band=0;
        }
    }

    start_year = current.day == future.day ? 0 : 365 - days_elapsed(current);

    end_year = days_elapsed(future);

    for(num_years=current.day+1; num_years<future.day; num_years){
        if(((num_years%4==0) && (num_years%100!=0))){
            total_days+=366;
        }
        else{
            total_days+=365;
        }
    }

     total_days += start_year + end_year;

     printf("\n\n El numero de dÃ­as transcurridos entre %i/%i/%i y %i/%i/%i es: %li dÃ­as \n", current.day, current.month, current.year, future.day, future.month, future.year, total_days);
}


int days_elapsed(date_t date)
{
    int sum=0;

    int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

    for (int cont=0;cont<date.month-1;cont++){
        sum+= months[cont];
    }

    sum+= date.day;

    if((((date.year % 4 == 0) && (date.year % 100 != 0)) || (date.year % 400==0)) && date.month>2){
        sum++;
    }

    return sum;
}

///////////////////////////////////////////////////PROBLEMA C////////////////////////////////////////////////
void get_temperature()
{
    
    //VARIABLES INICIALES//
    float temperature;
    char scale;
    char option;
    
    //AQUI SE PIDE LA ESCALA QUE SE ESTA UTILIZANDO, SI INGRESA UN VALOR 
    //INVALIDO RE REPETIRA HASTA QUE SEA UNO CORRECTO
    do{
        printf("\n Ingresa la escala que estas utilizando[C/F/K]: ");
        scanf(" %c",&scale);
    }while(scale!='C' && scale!='F' && scale!='K');

    //AQUI SE INGRESA LA TEMPERATURA//
    printf(" Ingresa la temperatura: ");
    scanf("%f",&temperature);
    void calculated_temperatur(char scale, float temperature);

    //SE DECLARA LA VARIABLE QUE UTILIZAREMOS 
    float converted_temperature;

    switch(scale){
        case 'C':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[F/K]: ");
                scanf(" %c",&option);
            }while(option!='F' && option!='K');

            if(option=='F'){
                converted_temperature=(temperature * (1.8)) + 32;
                printf(" %.2f Celsius a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
            else{
                converted_temperature=temperature + 273.15;
                printf(" %.2f Celsius a Kelvin son: %.2f",temperature,converted_temperature);
            }
            break;

        case 'F':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/K]: ");
                scanf(" %c",&option);
            }while(option!='C' && option!='K');

            if(option=='C'){
                converted_temperature=(temperature - 32) * (0.55555);
                printf(" %.2f Fahrenheit a Celsius son: %.2f",temperature,converted_temperature);
            } else{
                converted_temperature=((temperature - 32) * (0.555)) + 273.15;
                printf(" %.2f Fahrenheit a Kelvin son: %.2f",temperature,converted_temperature);
            }
            break;

        case 'K':
            do{
                printf("\n Ingresa la escala a la que la quieres convertir[C/F]: ");
                scanf(" %c",&option);
            } while(option!='C' && option!='F');  
             
            if(option=='C'){
                converted_temperature=temperature - 273.15;
               printf(" %.2f Kelvin a Celsius son: %.2f",temperature,converted_temperature);
            } else{
                converted_temperature=((temperature - 273.15) * (1.8)) + 32;
                printf("%.2f Kelvin a Fahrenheit son: %.2f",temperature,converted_temperature);
            }
            break;
    }
    printf("\n");
}

///////////////////////////////////////////////////PROBLEMA D////////////////////////////////////////////////
void average_age()
{
    FAMILY array_family[MAX];
    int i, members, year_2;
    float month, month_2, total;

    printf("\n NÃºmero de miembros en tu familia:  ");
    scanf("%d", &members);

    for(i = 0; i < members; i++) {
        printf("\n Edad en aÃ±os del integrante %d: ", i + 1);
        scanf("%d", &array_family[i].age_year);
        printf(" Edad en meses del integrante %d: ", i + 1);
        scanf("%f", &month);

        month *= CONSTANT; //AquÃ­ se pasan los meses a aÃ±os para asÃ­ poder sacar el promedio
        array_family[i].age_month = month;
        total = total + array_family[i].age_year + month;
    }

    total /= members;
    year_2 = total;
    month_2 = total - year_2;
    month_2 *= 10;
    month_2 = month_2 * 12 / 10;

    printf("\n El promedio de edad es %d aÃ±os y %.0f meses.\n", year_2, month_2);
}

///////////////////////////////////////////////////PROBLEMA E////////////////////////////////////////////////
void trigonometry()
{
    float rad, ans;
    int function;
    char op;
    do
    {
        fflush(stdin);

        printf("\n Ãngulo en radianes: ");
        scanf("%f",&rad);

        printf("\n 1. Seno");
        printf("\n 2. Coseno");
        printf("\n 3. Tangente");
        printf("\n\n FunciÃ³n a realizar: ");
        scanf("%d",&function);

        printf("\n");
        switch(function)
        {
            case 1:     //Funcion seno
                ans=sin(rad);
                printf(" Seno de %.2f radianes: %.2f \n", rad, ans);
                break;

            case 2:     //Funcion coseno
                ans=cos(rad);
                printf(" Coseno de %.2f radianes: %.2f \n", rad , ans);
                break;

            case 3:     //Funcion tangente
                ans=tan(rad);
                printf(" Tangente de %.2f radianes: %.2f \n", rad , ans);
                break;

            default:
                printf(" OpciÃ³n invÃ¡lida.\n");
        }

        printf("\n Continuar[s/n]: ");
        scanf(" %c",&op);

    }while(op=='s');
}

///////////////////////////////////////////////////PROBLEMA F////////////////////////////////////////////////
void g_estadistica()
{
    int size;
    double sample[MAX];

    do{
        printf("\n Ingresar tamano de la muestra: " );
        scanf("%d", &size);
        if(size <= 0 || size > MAX){
            printf("\n TamaÃ±o InvÃ¡lido: " );
        }
    } while(size <= 0 || size > MAX);

    printf("\n");
    scan_sample(sample, size);

    //Se ordenan los valores de la muestra desde el inicio, ya que se necesita para calcular la mediana y la moda.
    qsort(sample, size, sizeof(double), double_comparator);

    int op;
    do{
        fflush(stdin);
        printf("\n 1. Media aritmetica." );
        printf("\n 2. Moda." );
        printf("\n 3. Mediana." );
        printf("\n 4. Salir." );
        printf("\n\n Operacion a realizar: " );
		scanf("%d", &op);

        switch(op)
        {
            case 1:
                printf("\n Media aritmetica: %lf", get_arithmetic_mean(sample, size)); 
                break;

            case 2:
                printf("\n Moda: %lf", get_mode(sample, size)); 
                break;
            
            case 3:
                printf("\n Mediana: %lf", get_median(sample, size)); 
                break;
            
            case 4:
                printf("\n Saliendo..."); 
                break;
            
            default:
                printf("\n Opcion invÃ¡lida."); 
        }
        
        printf("\n");

    } while(op != 4);

}

//Leer la muestra de datos
void scan_sample(double *sample, int size)
{
    for(int i = 0; i < size; i++){
        printf(" Elemento %d: ", i+1);
        scanf("%lf", &sample[i]);
    }
}

//Comparador para la funciÃ³n qsort, regresa la diferencia entre dos double
int double_comparator(const void* a, const void* b)
{
    return *(double *)a - *(double *)b;
}

//Calcular la media arimÃ©tica sumando todos los valores, y dividiÃ©ndolos por el nÃºmero de valores.
double get_arithmetic_mean(double *sample, int size)
{
	double mean = 0;

	for(int i = 0; i < size; i++){
        mean += sample[i];
    }
	mean /= size;

	return mean;
}

//Calcular la moda eligiendo el valor que aparece con mayor frecuencia (se asume la muestra estÃ¡ ordenada).
double get_mode(double *sample, int size)
{
    double mode = sample[0]; //Se le da un valor por default
    int max_frequency = 0, current_frequency = 0;

    for(int i = 1; i < size; i++){
        
        if(sample[i] == sample[i-1]){ //Mientras sean iguales los elementos contiguos, se aumenta la frecuencia actual.
            current_frequency++;
        }else{
            if(current_frequency > max_frequency){ //Cuando se encuentra un valor diferente al actual, se compara la frecuencia del Ãºltimo con la frecuencia mÃ¡xima.
                mode = sample[i-1];
                max_frequency = current_frequency;
            }
            current_frequency = 0;
        }
    }

    return mode;
}

//Obtener el valor de la media (se asume la muestra estÃ¡ ordenada).
double get_median(double *sample, int size)
{
    int mid = size / 2;

	if(size % 2 == 0){ //si el no. de elementos es impar, se toma el promedio de ambos elementos de en medio.
        return (sample[mid] + sample[mid - 1]) / 2;
    }

    return sample[mid];
}

///////////////////////////////////////////////////PROBLEMA G////////////////////////////////////////////////
void factorial()
{
    int factorial=1;
    int contador, dato;

    printf("\n Factorial de: ");
    scanf("%d",&dato);

    for(contador=1;contador<=dato;contador++){
        factorial = factorial*contador;
    }
    
	printf(" El factorial de %d es %d\n",dato,factorial);
}
[15/09/22, 17:33:50] Mikel Barajas: Los demÃ¡s por favor prueben ponerla en replit
[15/09/22, 17:33:52] Mikel Barajas: Ya sea de aquÃ­
[15/09/22, 17:33:58] Mikel Barajas: O del archivo que va a estar en teams
[15/09/22, 17:38:09] Mikel Barajas: Ya estÃ¡ subida
[15/09/22, 17:38:19] Mikel Barajas: De nuevo Gracias a todos equipo
[15/09/22, 17:38:30] Mikel Barajas: Revise la en replit y en su mÃ¡quina
[15/09/22, 17:46:49] â€ª+52Â 444Â 718Â 5474â€¬: Si man, yo la preparo
[15/09/22, 17:52:23] Mikel Barajas: Gravias
[15/09/22, 17:52:27] Mikel Barajas: La llevas en tu compu el martes
[15/09/22, 17:52:41] Mikel Barajas: Por si se ocupa una demostraciÃ³n y salen mal los acentos
